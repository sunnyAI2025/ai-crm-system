# CRM系统测试数据准备脚本

## 概述

本文档提供了CRM系统测试所需的各种测试数据准备脚本，包括数据库测试数据、AI功能测试数据集、性能测试数据和模拟数据生成工具。

## 数据库测试数据

### 1. 基础测试数据脚本

```sql
-- test_data_init.sql
-- CRM系统基础测试数据初始化脚本

-- 清理现有测试数据
DELETE FROM tracking_records WHERE id > 0;
DELETE FROM order_items WHERE id > 0;
DELETE FROM payments WHERE id > 0;
DELETE FROM orders WHERE id > 0;
DELETE FROM customers WHERE id > 0;
DELETE FROM leads WHERE id > 0;
DELETE FROM campaign_daily_stats WHERE id > 0;
DELETE FROM campaigns WHERE id > 0;
DELETE FROM users WHERE id > 1; -- 保留管理员账户
DELETE FROM roles WHERE id > 5;
DELETE FROM departments WHERE id > 4;

-- 重置序列
ALTER SEQUENCE departments_id_seq RESTART WITH 5;
ALTER SEQUENCE roles_id_seq RESTART WITH 6;
ALTER SEQUENCE users_id_seq RESTART WITH 2;
ALTER SEQUENCE leads_id_seq RESTART WITH 1;
ALTER SEQUENCE customers_id_seq RESTART WITH 1;
ALTER SEQUENCE orders_id_seq RESTART WITH 1;
ALTER SEQUENCE campaigns_id_seq RESTART WITH 1;

-- 插入测试部门数据
INSERT INTO departments (id, name, description, parent_id, status, created_at, updated_at) VALUES
(5, '测试销售部', '专门用于测试的销售部门', 2, 1, NOW(), NOW()),
(6, '测试营销部', '专门用于测试的营销部门', 3, 1, NOW(), NOW()),
(7, '测试客服部', '专门用于测试的客服部门', 1, 1, NOW(), NOW());

-- 插入测试角色数据
INSERT INTO roles (id, name, description, department_id, permissions, status, created_at, updated_at) VALUES
(6, '测试销售经理', '测试用销售经理角色', 5, '{"dashboard":{"view":true},"sales":{"leads":{"view":true,"create":true,"edit":true,"assign":true},"customers":{"view":true,"create":true,"edit":true},"orders":{"view":true,"create":true,"edit":true}}}', 1, NOW(), NOW()),
(7, '测试销售员', '测试用销售员角色', 5, '{"sales":{"leads":{"view":true,"create":true,"edit":true},"customers":{"view":true,"create":true},"orders":{"view":true,"create":true}}}', 1, NOW(), NOW()),
(8, '测试营销员', '测试用营销员角色', 6, '{"marketing":{"campaigns":{"view":true,"create":true,"edit":true}}}', 1, NOW(), NOW());

-- 插入测试用户数据
INSERT INTO users (username, password, name, phone, department_id, role_id, status, created_at, updated_at) VALUES
('test_sales_manager', '$2a$10$N.zmdr9k7uOCQb376NoUnuTJ8iAt6Z5EHsM7lbqxrDB3gF.eZBJvG', '测试销售经理', '13800001001', 5, 6, 1, NOW(), NOW()),
('test_sales_user1', '$2a$10$N.zmdr9k7uOCQb376NoUnuTJ8iAt6Z5EHsM7lbqxrDB3gF.eZBJvG', '测试销售员1', '13800001002', 5, 7, 1, NOW(), NOW()),
('test_sales_user2', '$2a$10$N.zmdr9k7uOCQb376NoUnuTJ8iAt6Z5EHsM7lbqxrDB3gF.eZBJvG', '测试销售员2', '13800001003', 5, 7, 1, NOW(), NOW()),
('test_marketing_user', '$2a$10$N.zmdr9k7uOCQb376NoUnuTJ8iAt6Z5EHsM7lbqxrDB3gF.eZBJvG', '测试营销员', '13800001004', 6, 8, 1, NOW(), NOW()),
('test_customer_service', '$2a$10$N.zmdr9k7uOCQb376NoUnuTJ8iAt6Z5EHsM7lbqxrDB3gF.eZBJvG', '测试客服', '13800001005', 7, 4, 1, NOW(), NOW());

-- 插入测试线索数据
INSERT INTO leads (name, phone, business_type, source_channel, intention_level, assigned_user_id, status, created_at, updated_at, remark) VALUES
('张三', '13900001001', '会计培训', 'SEM搜索', 1, 2, 1, NOW() - INTERVAL '10 days', NOW(), '通过百度搜索找到我们，对注册会计师课程很感兴趣'),
('李四', '13900001002', '学历提升', '表单填写', 2, 2, 1, NOW() - INTERVAL '8 days', NOW(), '通过官网表单咨询本科学历提升'),
('王五', '13900001003', '职业资格', '海报活动', 1, 3, 2, NOW() - INTERVAL '6 days', NOW(), '看到地铁广告后电话咨询人力资源管理师'),
('赵六', '13900001004', '技能培训', '电话咨询', 3, 3, 1, NOW() - INTERVAL '4 days', NOW(), '朋友推荐，咨询IT技能培训'),
('钱七', '13900001005', '会计培训', 'SEM搜索', 1, 2, 3, NOW() - INTERVAL '15 days', NOW(), '已转化为客户'),
('孙八', '13900001006', '学历提升', '表单填写', 2, 2, 1, NOW() - INTERVAL '2 days', NOW(), '专科想升本科'),
('周九', '13900001007', '职业资格', '海报活动', 1, 3, 1, NOW() - INTERVAL '1 day', NOW(), '咨询一级建造师考试培训'),
('吴十', '13900001008', '会计培训', 'SEM搜索', 2, 2, 2, NOW() - INTERVAL '12 days', NOW(), '正在跟进中，已发送课程资料');

-- 插入测试客户数据
INSERT INTO customers (name, contact_person, phone, business_type, source_channel, customer_level, assigned_user_id, status, source_lead_id, created_at, updated_at, total_order_amount) VALUES
('钱七', '钱七', '13900001005', '会计培训', 'SEM搜索', 'A', 2, 3, 5, NOW() - INTERVAL '14 days', NOW(), 4980.00),
('北京ABC公司', '刘经理', '13900002001', '职业资格', '电话咨询', 'B', 3, 1, NULL, NOW() - INTERVAL '30 days', NOW(), 0),
('上海XYZ企业', '陈总', '13900002002', '技能培训', '表单填写', 'A', 2, 2, NULL, NOW() - INTERVAL '25 days', NOW(), 0),
('深圳123有限公司', '张主管', '13900002003', '学历提升', 'SEM搜索', 'B', 3, 1, NULL, NOW() - INTERVAL '20 days', NOW(), 0);

-- 插入测试订单数据
INSERT INTO orders (order_no, customer_id, product_name, quantity, unit_price, total_amount, order_date, assigned_user_id, status, payment_status, paid_amount, service_start_date, service_end_date, created_at, updated_at) VALUES
('ORD202403150001', 1, '注册会计师全科班', 1, 4980.00, 4980.00, NOW() - INTERVAL '13 days', 2, 4, 3, 4980.00, NOW() - INTERVAL '7 days', NOW() + INTERVAL '60 days', NOW() - INTERVAL '13 days', NOW()),
('ORD202403160001', 2, '人力资源管理师二级', 1, 2980.00, 2980.00, NOW() - INTERVAL '5 days', 3, 2, 1, 0, NOW() + INTERVAL '10 days', NOW() + INTERVAL '40 days', NOW() - INTERVAL '5 days', NOW()),
('ORD202403170001', 3, 'Java开发工程师培训', 1, 6980.00, 6980.00, NOW() - INTERVAL '3 days', 2, 1, 2, 3000.00, NOW() + INTERVAL '14 days', NOW() + INTERVAL '104 days', NOW() - INTERVAL '3 days', NOW());

-- 插入测试支付记录
INSERT INTO payments (order_id, payment_amount, payment_method, payment_date, payment_status, transaction_no, created_at, updated_at, remark) VALUES
(1, 4980.00, '支付宝', NOW() - INTERVAL '12 days', 1, 'PAY20240315001', NOW() - INTERVAL '12 days', NOW(), '一次性付清'),
(3, 3000.00, '银行转账', NOW() - INTERVAL '2 days', 1, 'TRF20240317001', NOW() - INTERVAL '2 days', NOW(), '首期付款');

-- 插入测试跟踪记录
INSERT INTO tracking_records (lead_id, customer_id, content, tracking_type, next_follow_time, created_by, created_at, updated_at) VALUES
(1, NULL, '首次电话联系，客户表示对注册会计师培训很感兴趣，约定明天详细介绍课程', '电话沟通', NOW() + INTERVAL '1 day', 2, NOW() - INTERVAL '9 days', NOW()),
(1, NULL, '发送了课程详细资料和价格，客户需要考虑几天', '资料发送', NOW() + INTERVAL '3 days', 2, NOW() - INTERVAL '7 days', NOW()),
(2, NULL, '客户咨询学历提升相关政策，已详细解答', '电话沟通', NOW() + INTERVAL '2 days', 2, NOW() - INTERVAL '6 days', NOW()),
(3, NULL, '客户到访公司，实地了解培训环境和师资力量', '面谈', NOW() + INTERVAL '5 days', 3, NOW() - INTERVAL '4 days', NOW()),
(NULL, 1, '客户反馈课程进度良好，学习积极性很高', '学习跟踪', NOW() + INTERVAL '7 days', 2, NOW() - INTERVAL '3 days', NOW());

-- 插入测试推广活动数据
INSERT INTO campaigns (name, description, start_date, end_date, budget, actual_cost, channel, target_audience, status, created_by, created_at, updated_at) VALUES
('春季会计培训推广', '针对春季招生的会计培训推广活动', NOW() - INTERVAL '30 days', NOW() + INTERVAL '30 days', 50000.00, 25000.00, 'SEM搜索', '在职人员', 1, 5, NOW() - INTERVAL '30 days', NOW()),
('学历提升专项活动', '针对专科生的本科学历提升推广', NOW() - INTERVAL '20 days', NOW() + INTERVAL '40 days', 30000.00, 18000.00, '表单填写', '专科毕业生', 1, 5, NOW() - INTERVAL '20 days', NOW()),
('职业资格考试季', '针对各类职业资格考试的推广活动', NOW() - INTERVAL '15 days', NOW() + INTERVAL '45 days', 40000.00, 22000.00, '海报活动', '考证人群', 1, 5, NOW() - INTERVAL '15 days', NOW());

-- 插入测试活动统计数据
INSERT INTO campaign_daily_stats (campaign_id, stat_date, leads_count, cost, conversion_rate, created_at, updated_at) VALUES
(1, NOW() - INTERVAL '10 days', 15, 1200.00, 0.08, NOW() - INTERVAL '9 days', NOW()),
(1, NOW() - INTERVAL '9 days', 12, 1100.00, 0.10, NOW() - INTERVAL '8 days', NOW()),
(1, NOW() - INTERVAL '8 days', 18, 1350.00, 0.09, NOW() - INTERVAL '7 days', NOW()),
(2, NOW() - INTERVAL '10 days', 8, 800.00, 0.12, NOW() - INTERVAL '9 days', NOW()),
(2, NOW() - INTERVAL '9 days', 10, 950.00, 0.11, NOW() - INTERVAL '8 days', NOW()),
(3, NOW() - INTERVAL '8 days', 22, 1500.00, 0.07, NOW() - INTERVAL '7 days', NOW());

-- 插入测试操作日志
INSERT INTO operation_logs (user_id, operation_type, resource_type, resource_id, operation_content, ip_address, created_at) VALUES
(2, 'CREATE', 'LEAD', 1, '创建线索：张三', '192.168.1.100', NOW() - INTERVAL '10 days'),
(2, 'UPDATE', 'LEAD', 1, '更新线索跟踪记录', '192.168.1.100', NOW() - INTERVAL '9 days'),
(2, 'CONVERT', 'LEAD', 5, '线索转化为客户', '192.168.1.100', NOW() - INTERVAL '14 days'),
(2, 'CREATE', 'ORDER', 1, '创建订单：注册会计师全科班', '192.168.1.101', NOW() - INTERVAL '13 days'),
(3, 'CREATE', 'LEAD', 3, '创建线索：王五', '192.168.1.102', NOW() - INTERVAL '6 days');

COMMIT;
```

### 2. 大数据量测试数据生成脚本

```python
# scripts/generate_test_data.py
"""
CRM系统大数据量测试数据生成脚本
"""

import random
import psycopg2
from datetime import datetime, timedelta
from faker import Faker
import os
from decimal import Decimal

# 初始化Faker
fake = Faker('zh_CN')

# 数据库连接配置
DATABASE_URL = os.getenv('DATABASE_URL', 
    'postgresql://neondb_owner:npg_TCx79eZizfGU@ep-plain-moon-aewc6a58-pooler.c-2.us-east-2.aws.neon.tech/neondb?sslmode=require&channel_binding=require')

# 业务数据配置
BUSINESS_TYPES = ['会计培训', '学历提升', '职业资格', '技能培训']
SOURCE_CHANNELS = ['SEM搜索', '表单填写', '海报活动', '电话咨询']
CUSTOMER_LEVELS = ['A', 'B', 'C']
PRODUCT_NAMES = [
    '注册会计师全科班', '初级会计职称', '中级会计职称',
    '专升本学历提升', '本科学历提升', '研究生学历提升',
    '人力资源管理师', '一级建造师', '二级建造师',
    'Java开发工程师', 'Python开发工程师', 'Web前端开发'
]
PAYMENT_METHODS = ['支付宝', '微信支付', '银行转账', '现金', '刷卡']

class TestDataGenerator:
    def __init__(self):
        self.conn = psycopg2.connect(DATABASE_URL)
        self.cursor = self.conn.cursor()
    
    def close(self):
        """关闭数据库连接"""
        self.cursor.close()
        self.conn.close()
    
    def generate_users(self, count=100):
        """生成测试用户数据"""
        print(f"生成 {count} 个测试用户...")
        
        users_data = []
        for i in range(count):
            username = f"test_user_{i+1:04d}"
            name = fake.name()
            phone = fake.phone_number()
            department_id = random.randint(1, 7)
            role_id = random.randint(2, 8)
            status = 1
            
            users_data.append((
                username, 
                '$2a$10$N.zmdr9k7uOCQb376NoUnuTJ8iAt6Z5EHsM7lbqxrDB3gF.eZBJvG',  # 默认密码
                name, phone, department_id, role_id, status
            ))
        
        # 批量插入
        insert_sql = """
        INSERT INTO users (username, password, name, phone, department_id, role_id, status, created_at, updated_at)
        VALUES (%s, %s, %s, %s, %s, %s, %s, NOW(), NOW())
        """
        
        self.cursor.executemany(insert_sql, users_data)
        self.conn.commit()
        print(f"✅ 成功生成 {count} 个用户")
    
    def generate_leads(self, count=5000):
        """生成测试线索数据"""
        print(f"生成 {count} 个测试线索...")
        
        # 获取用户ID列表
        self.cursor.execute("SELECT id FROM users WHERE role_id IN (3, 6, 7) AND status = 1")
        user_ids = [row[0] for row in self.cursor.fetchall()]
        
        if not user_ids:
            print("❌ 没有找到销售员用户，请先生成用户数据")
            return
        
        leads_data = []
        for i in range(count):
            name = fake.name()
            phone = fake.phone_number()
            business_type = random.choice(BUSINESS_TYPES)
            source_channel = random.choice(SOURCE_CHANNELS)
            intention_level = random.randint(1, 3)
            assigned_user_id = random.choice(user_ids)
            status = random.choices([1, 2, 3, 4], weights=[60, 25, 10, 5])[0]  # 大部分是待跟进
            
            # 随机生成创建时间（过去90天内）
            created_at = fake.date_time_between(start_date='-90d', end_date='now')
            
            remark = self.generate_lead_remark(business_type, source_channel)
            
            leads_data.append((
                name, phone, business_type, source_channel, intention_level,
                assigned_user_id, status, created_at, created_at, remark
            ))
        
        # 批量插入
        insert_sql = """
        INSERT INTO leads (name, phone, business_type, source_channel, intention_level, 
                          assigned_user_id, status, created_at, updated_at, remark)
        VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
        """
        
        self.cursor.executemany(insert_sql, leads_data)
        self.conn.commit()
        print(f"✅ 成功生成 {count} 个线索")
    
    def generate_customers(self, count=1000):
        """生成测试客户数据"""
        print(f"生成 {count} 个测试客户...")
        
        # 获取用户ID列表
        self.cursor.execute("SELECT id FROM users WHERE role_id IN (3, 6, 7) AND status = 1")
        user_ids = [row[0] for row in self.cursor.fetchall()]
        
        # 获取已转化的线索ID列表
        self.cursor.execute("SELECT id FROM leads WHERE status = 3 LIMIT 200")
        lead_ids = [row[0] for row in self.cursor.fetchall()]
        
        customers_data = []
        for i in range(count):
            name = fake.company() if random.random() > 0.7 else fake.name()
            contact_person = fake.name()
            phone = fake.phone_number()
            business_type = random.choice(BUSINESS_TYPES)
            source_channel = random.choice(SOURCE_CHANNELS)
            customer_level = random.choice(CUSTOMER_LEVELS)
            assigned_user_id = random.choice(user_ids)
            status = random.choices([1, 2, 3, 4], weights=[40, 30, 25, 5])[0]
            
            # 部分客户来自线索转化
            source_lead_id = random.choice(lead_ids) if lead_ids and random.random() > 0.6 else None
            
            created_at = fake.date_time_between(start_date='-120d', end_date='now')
            
            # 已成单客户设置订单金额
            total_order_amount = 0
            if status == 3:
                total_order_amount = random.randint(1000, 10000)
            
            customers_data.append((
                name, contact_person, phone, business_type, source_channel,
                customer_level, assigned_user_id, status, source_lead_id,
                created_at, created_at, total_order_amount
            ))
        
        insert_sql = """
        INSERT INTO customers (name, contact_person, phone, business_type, source_channel,
                              customer_level, assigned_user_id, status, source_lead_id,
                              created_at, updated_at, total_order_amount)
        VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
        """
        
        self.cursor.executemany(insert_sql, customers_data)
        self.conn.commit()
        print(f"✅ 成功生成 {count} 个客户")
    
    def generate_orders(self, count=800):
        """生成测试订单数据"""
        print(f"生成 {count} 个测试订单...")
        
        # 获取客户ID列表
        self.cursor.execute("SELECT id FROM customers WHERE status IN (2, 3)")
        customer_ids = [row[0] for row in self.cursor.fetchall()]
        
        if not customer_ids:
            print("❌ 没有找到合适的客户，请先生成客户数据")
            return
        
        # 获取用户ID列表
        self.cursor.execute("SELECT id FROM users WHERE role_id IN (3, 6, 7) AND status = 1")
        user_ids = [row[0] for row in self.cursor.fetchall()]
        
        orders_data = []
        for i in range(count):
            order_no = f"ORD{datetime.now().strftime('%Y%m%d')}{i+1:05d}"
            customer_id = random.choice(customer_ids)
            product_name = random.choice(PRODUCT_NAMES)
            quantity = 1
            unit_price = Decimal(str(random.randint(1000, 15000)))
            total_amount = unit_price * quantity
            
            order_date = fake.date_time_between(start_date='-90d', end_date='now')
            assigned_user_id = random.choice(user_ids)
            
            # 订单状态分布
            status = random.choices([1, 2, 3, 4, 5, 6], weights=[20, 15, 10, 20, 30, 5])[0]
            
            # 支付状态
            if status >= 3:
                payment_status = random.choices([1, 2, 3], weights=[10, 30, 60])[0]
                paid_amount = 0
                if payment_status == 2:  # 部分付款
                    paid_amount = total_amount * Decimal(str(random.uniform(0.3, 0.8)))
                elif payment_status == 3:  # 已支付
                    paid_amount = total_amount
            else:
                payment_status = 1
                paid_amount = 0
            
            # 服务时间
            service_start_date = order_date.date() + timedelta(days=random.randint(1, 30))
            service_end_date = service_start_date + timedelta(days=random.randint(30, 180))
            
            orders_data.append((
                order_no, customer_id, product_name, quantity, unit_price,
                total_amount, order_date, assigned_user_id, status,
                payment_status, paid_amount, service_start_date, service_end_date,
                order_date, order_date
            ))
        
        insert_sql = """
        INSERT INTO orders (order_no, customer_id, product_name, quantity, unit_price,
                           total_amount, order_date, assigned_user_id, status,
                           payment_status, paid_amount, service_start_date, service_end_date,
                           created_at, updated_at)
        VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
        """
        
        self.cursor.executemany(insert_sql, orders_data)
        self.conn.commit()
        print(f"✅ 成功生成 {count} 个订单")
    
    def generate_payments(self, count=1200):
        """生成测试支付记录"""
        print(f"生成 {count} 个测试支付记录...")
        
        # 获取有支付金额的订单
        self.cursor.execute("""
        SELECT id, total_amount, paid_amount, created_at 
        FROM orders 
        WHERE payment_status IN (2, 3) AND paid_amount > 0
        """)
        orders = self.cursor.fetchall()
        
        if not orders:
            print("❌ 没有找到有支付记录的订单")
            return
        
        payments_data = []
        for i in range(min(count, len(orders) * 3)):  # 每个订单最多3笔支付
            order = random.choice(orders)
            order_id, total_amount, paid_amount, order_date = order
            
            # 生成支付金额（不超过已支付金额）
            max_payment = min(paid_amount, total_amount)
            payment_amount = Decimal(str(random.uniform(float(max_payment) * 0.3, float(max_payment))))
            
            payment_method = random.choice(PAYMENT_METHODS)
            payment_date = fake.date_time_between(start_date=order_date, end_date='now')
            payment_status = 1  # 支付成功
            transaction_no = f"PAY{payment_date.strftime('%Y%m%d%H%M%S')}{random.randint(1000, 9999)}"
            
            remark = self.generate_payment_remark(payment_method)
            
            payments_data.append((
                order_id, payment_amount, payment_method, payment_date,
                payment_status, transaction_no, payment_date, payment_date, remark
            ))
        
        insert_sql = """
        INSERT INTO payments (order_id, payment_amount, payment_method, payment_date,
                             payment_status, transaction_no, created_at, updated_at, remark)
        VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
        """
        
        self.cursor.executemany(insert_sql, payments_data)
        self.conn.commit()
        print(f"✅ 成功生成 {len(payments_data)} 个支付记录")
    
    def generate_tracking_records(self, count=8000):
        """生成测试跟踪记录"""
        print(f"生成 {count} 个测试跟踪记录...")
        
        # 获取线索和客户ID
        self.cursor.execute("SELECT id FROM leads WHERE status IN (1, 2)")
        lead_ids = [row[0] for row in self.cursor.fetchall()]
        
        self.cursor.execute("SELECT id FROM customers WHERE status IN (1, 2, 3)")
        customer_ids = [row[0] for row in self.cursor.fetchall()]
        
        self.cursor.execute("SELECT id FROM users WHERE role_id IN (3, 4, 6, 7) AND status = 1")
        user_ids = [row[0] for row in self.cursor.fetchall()]
        
        tracking_types = ['电话沟通', '面谈', '资料发送', '邮件联系', '微信沟通', '回访']
        
        tracking_data = []
        for i in range(count):
            # 70%跟踪线索，30%跟踪客户
            if random.random() < 0.7 and lead_ids:
                lead_id = random.choice(lead_ids)
                customer_id = None
            else:
                lead_id = None
                customer_id = random.choice(customer_ids) if customer_ids else None
            
            content = self.generate_tracking_content()
            tracking_type = random.choice(tracking_types)
            
            created_at = fake.date_time_between(start_date='-60d', end_date='now')
            next_follow_time = created_at + timedelta(days=random.randint(1, 14))
            created_by = random.choice(user_ids)
            
            tracking_data.append((
                lead_id, customer_id, content, tracking_type,
                next_follow_time, created_by, created_at, created_at
            ))
        
        insert_sql = """
        INSERT INTO tracking_records (lead_id, customer_id, content, tracking_type,
                                     next_follow_time, created_by, created_at, updated_at)
        VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
        """
        
        self.cursor.executemany(insert_sql, tracking_data)
        self.conn.commit()
        print(f"✅ 成功生成 {count} 个跟踪记录")
    
    def generate_campaigns(self, count=50):
        """生成测试推广活动数据"""
        print(f"生成 {count} 个测试推广活动...")
        
        self.cursor.execute("SELECT id FROM users WHERE role_id IN (2, 5, 8) AND status = 1")
        user_ids = [row[0] for row in self.cursor.fetchall()]
        
        campaigns_data = []
        for i in range(count):
            name = f"{random.choice(['春季', '夏季', '秋季', '冬季'])}{random.choice(BUSINESS_TYPES)}推广活动{i+1}"
            description = f"针对{random.choice(['在职人员', '学生群体', '企业客户', '个人用户'])}的专项推广活动"
            
            start_date = fake.date_between(start_date='-180d', end_date='+30d')
            end_date = start_date + timedelta(days=random.randint(30, 90))
            
            budget = Decimal(str(random.randint(10000, 100000)))
            actual_cost = budget * Decimal(str(random.uniform(0.3, 0.9)))
            
            channel = random.choice(SOURCE_CHANNELS)
            target_audience = random.choice(['在职人员', '学生群体', '企业客户', '考证人群'])
            status = random.choices([1, 2, 3], weights=[60, 20, 20])[0]
            created_by = random.choice(user_ids)
            
            campaigns_data.append((
                name, description, start_date, end_date, budget, actual_cost,
                channel, target_audience, status, created_by,
                start_date, start_date
            ))
        
        insert_sql = """
        INSERT INTO campaigns (name, description, start_date, end_date, budget, actual_cost,
                              channel, target_audience, status, created_by, created_at, updated_at)
        VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
        """
        
        self.cursor.executemany(insert_sql, campaigns_data)
        self.conn.commit()
        print(f"✅ 成功生成 {count} 个推广活动")
    
    def generate_lead_remark(self, business_type, source_channel):
        """生成线索备注"""
        remarks = {
            '会计培训': [
                '对注册会计师课程很感兴趣，询问考试通过率',
                '想了解初级会计职称培训的具体安排',
                '正在准备中级会计考试，需要专业指导',
                '企业财务人员，希望提升专业技能'
            ],
            '学历提升': [
                '专科毕业想升本科，咨询相关政策',
                '在职人员，希望通过学历提升获得晋升机会',
                '了解网络教育和成人高考的区别',
                '想报读研究生课程，询问入学条件'
            ],
            '职业资格': [
                '准备考人力资源管理师，询问培训安排',
                '建筑行业从业者，需要一级建造师证书',
                '对心理咨询师职业很感兴趣',
                '企业管理人员，想考取项目管理师'
            ],
            '技能培训': [
                '零基础想学Java开发，询问就业前景',
                '设计师想学UI/UX设计课程',
                '对Python数据分析很感兴趣',
                '想转行做前端开发，需要系统学习'
            ]
        }
        
        channel_prefixes = {
            'SEM搜索': '通过搜索引擎找到我们，',
            '表单填写': '通过官网表单咨询，',
            '海报活动': '看到宣传广告后联系，',
            '电话咨询': '朋友推荐后电话咨询，'
        }
        
        prefix = channel_prefixes.get(source_channel, '')
        remark_list = remarks.get(business_type, ['一般咨询'])
        
        return prefix + random.choice(remark_list)
    
    def generate_payment_remark(self, payment_method):
        """生成支付备注"""
        remarks = {
            '支付宝': ['支付宝扫码支付', '支付宝转账', '花呗分期支付'],
            '微信支付': ['微信扫码支付', '微信转账', '微信零钱支付'],
            '银行转账': ['网银转账', '手机银行转账', 'ATM转账'],
            '现金': ['现金支付', '现场缴费'],
            '刷卡': ['信用卡支付', '储蓄卡支付']
        }
        
        method_remarks = remarks.get(payment_method, ['在线支付'])
        return random.choice(method_remarks)
    
    def generate_tracking_content(self):
        """生成跟踪内容"""
        contents = [
            '电话联系客户，了解具体需求和预算情况',
            '发送了详细的课程介绍和价格方案',
            '客户表示需要和家人商量，约定下次联系时间',
            '邀请客户到公司实地参观和试听课程',
            '客户对价格有疑虑，需要进一步沟通',
            '发送了学员就业案例和成功故事',
            '客户决定报名，准备签署培训合同',
            '跟进学习进度，客户反馈良好',
            '解答客户关于考试政策的疑问',
            '提醒客户按时参加培训课程'
        ]
        
        return random.choice(contents)
    
    def generate_all_test_data(self):
        """生成所有测试数据"""
        print("🚀 开始生成CRM系统测试数据...")
        
        try:
            # 按依赖关系生成数据
            self.generate_users(100)
            self.generate_leads(5000)
            self.generate_customers(1000)
            self.generate_orders(800)
            self.generate_payments(1200)
            self.generate_tracking_records(8000)
            self.generate_campaigns(50)
            
            print("✅ 所有测试数据生成完成！")
            
            # 显示数据统计
            self.show_data_statistics()
            
        except Exception as e:
            print(f"❌ 生成测试数据时出错: {e}")
            self.conn.rollback()
        finally:
            self.close()
    
    def show_data_statistics(self):
        """显示数据统计信息"""
        print("\n📊 数据统计信息:")
        
        tables = [
            ('users', '用户'),
            ('leads', '线索'),
            ('customers', '客户'),
            ('orders', '订单'),
            ('payments', '支付记录'),
            ('tracking_records', '跟踪记录'),
            ('campaigns', '推广活动')
        ]
        
        for table, name in tables:
            self.cursor.execute(f"SELECT COUNT(*) FROM {table}")
            count = self.cursor.fetchone()[0]
            print(f"  {name}: {count:,} 条")

if __name__ == "__main__":
    generator = TestDataGenerator()
    generator.generate_all_test_data()
```

### 3. AI功能测试数据集

```python
# scripts/generate_ai_test_data.py
"""
AI功能测试数据集生成脚本
"""

import pandas as pd
import numpy as np
import random
from datetime import datetime, timedelta
import json
import os

class AITestDataGenerator:
    def __init__(self):
        self.output_dir = "test_data/ai_datasets"
        os.makedirs(self.output_dir, exist_ok=True)
    
    def generate_sales_trend_data(self):
        """生成销售趋势预测测试数据"""
        print("生成销售趋势预测测试数据...")
        
        # 生成24个月的历史数据
        dates = pd.date_range(start='2022-01-01', end='2023-12-31', freq='M')
        
        # 基础趋势：逐月增长
        base_trend = np.linspace(30000, 60000, len(dates))
        
        # 季节性影响
        seasonal = np.sin(np.arange(len(dates)) * 2 * np.pi / 12) * 5000
        
        # 随机波动
        noise = np.random.normal(0, 3000, len(dates))
        
        # 合成收入数据
        revenue = base_trend + seasonal + noise
        
        # 生成相关指标
        order_count = (revenue / 300 + np.random.normal(0, 20, len(dates))).astype(int)
        unique_customers = (order_count * 0.8 + np.random.normal(0, 10, len(dates))).astype(int)
        avg_order_value = revenue / order_count
        
        # 营销支出数据
        marketing_spend = revenue * 0.15 + np.random.normal(0, 2000, len(dates))
        
        data = pd.DataFrame({
            'date': dates,
            'revenue': revenue.round(2),
            'order_count': order_count,
            'unique_customers': unique_customers,
            'avg_order_value': avg_order_value.round(2),
            'marketing_spend': marketing_spend.round(2),
            'month': dates.month,
            'quarter': dates.quarter,
            'year': dates.year
        })
        
        data.to_csv(f"{self.output_dir}/sales_trend_data.csv", index=False)
        print(f"✅ 销售趋势数据已保存到 {self.output_dir}/sales_trend_data.csv")
        
        return data
    
    def generate_customer_churn_data(self):
        """生成客户流失预测测试数据"""
        print("生成客户流失预测测试数据...")
        
        n_customers = 2000
        
        # 生成客户特征
        data = {
            'customer_id': range(1, n_customers + 1),
            'days_since_last_order': np.random.exponential(30, n_customers),
            'order_frequency': np.random.gamma(2, 0.5, n_customers),
            'avg_order_value': np.random.normal(500, 200, n_customers),
            'total_spent': np.random.lognormal(8, 1, n_customers),
            'interaction_frequency': np.random.gamma(1.5, 2, n_customers),
            'days_since_last_contact': np.random.exponential(20, n_customers),
            'support_ticket_count': np.random.poisson(1, n_customers),
            'payment_delay': np.random.exponential(5, n_customers),
            'customer_age': np.random.uniform(30, 730, n_customers),
            'business_type': np.random.choice([0, 1, 2, 3], n_customers),  # 编码后的业务类型
            'source_channel': np.random.choice([0, 1, 2, 3], n_customers)  # 编码后的来源渠道
        }
        
        df = pd.DataFrame(data)
        
        # 生成流失标签（基于特征的逻辑规则）
        churn_probability = (
            0.3 * (df['days_since_last_order'] > 60) +
            0.2 * (df['order_frequency'] < 1) +
            0.2 * (df['days_since_last_contact'] > 30) +
            0.1 * (df['support_ticket_count'] > 2) +
            0.1 * (df['payment_delay'] > 10) +
            0.1 * np.random.random(n_customers)
        )
        
        df['churn'] = (churn_probability > 0.5).astype(int)
        df['churn_probability'] = churn_probability
        
        df.to_csv(f"{self.output_dir}/customer_churn_data.csv", index=False)
        print(f"✅ 客户流失数据已保存到 {self.output_dir}/customer_churn_data.csv")
        
        return df
    
    def generate_sentiment_analysis_data(self):
        """生成情感分析测试数据"""
        print("生成情感分析测试数据...")
        
        # 正面评价样本
        positive_texts = [
            "课程内容非常丰富，老师讲解很详细，学到了很多实用的知识",
            "服务态度很好，客服回复及时，解决了我的问题",
            "培训效果超出预期，推荐给朋友了",
            "价格合理，性价比很高，值得推荐",
            "老师专业水平很高，课程安排合理",
            "学习环境很好，设施完善",
            "课程更新及时，跟上了行业发展趋势",
            "考试通过率很高，培训效果明显"
        ]
        
        # 负面评价样本
        negative_texts = [
            "课程内容过时，与实际工作脱节",
            "服务态度差，客服回复很慢",
            "价格太贵，性价比不高",
            "老师水平一般，讲解不够清楚",
            "教学设施陈旧，学习环境差",
            "课程安排不合理，时间冲突",
            "考试通过率低，培训效果不明显",
            "退费困难，服务体验差"
        ]
        
        # 中性评价样本
        neutral_texts = [
            "课程还可以，有一定的帮助",
            "老师讲课一般，没有特别突出的地方",
            "价格适中，课程内容基本满足需求",
            "服务还行，有改进的空间",
            "整体感觉还不错，有收获",
            "课程安排基本合理，内容比较全面",
            "学习环境还可以，设施基本够用",
            "培训效果一般，符合预期"
        ]
        
        # 生成测试数据
        texts = []
        labels = []
        
        # 添加正面样本
        for _ in range(200):
            text = random.choice(positive_texts)
            texts.append(text + "，" + random.choice(positive_texts))
            labels.append(1)  # 正面
        
        # 添加负面样本
        for _ in range(200):
            text = random.choice(negative_texts)
            texts.append(text + "，" + random.choice(negative_texts))
            labels.append(-1)  # 负面
        
        # 添加中性样本
        for _ in range(100):
            text = random.choice(neutral_texts)
            texts.append(text + "，" + random.choice(neutral_texts))
            labels.append(0)  # 中性
        
        df = pd.DataFrame({
            'text': texts,
            'sentiment_label': labels,
            'customer_id': np.random.randint(1, 1000, len(texts)),
            'created_at': pd.date_range(start='2024-01-01', periods=len(texts), freq='H')
        })
        
        df.to_csv(f"{self.output_dir}/sentiment_analysis_data.csv", index=False)
        print(f"✅ 情感分析数据已保存到 {self.output_dir}/sentiment_analysis_data.csv")
        
        return df
    
    def generate_recommendation_data(self):
        """生成推荐系统测试数据"""
        print("生成推荐系统测试数据...")
        
        n_users = 500
        n_products = 50
        
        # 生成用户-产品交互矩阵
        interactions = []
        
        products = [
            "注册会计师培训", "初级会计职称", "中级会计职称",
            "专升本学历", "本科学历", "研究生学历",
            "人力资源管理师", "一级建造师", "二级建造师",
            "Java开发", "Python开发", "Web前端开发"
        ] * 5  # 扩展到50个产品
        
        for user_id in range(1, n_users + 1):
            # 每个用户与5-15个产品有交互
            n_interactions = random.randint(5, 15)
            user_products = random.sample(range(n_products), n_interactions)
            
            for product_id in user_products:
                # 生成评分（1-5）
                rating = random.choices([1, 2, 3, 4, 5], weights=[5, 10, 20, 35, 30])[0]
                
                # 生成交互类型
                interaction_type = random.choices(
                    ['view', 'purchase', 'inquiry', 'favorite'],
                    weights=[50, 20, 20, 10]
                )[0]
                
                interactions.append({
                    'user_id': user_id,
                    'product_id': product_id,
                    'product_name': products[product_id],
                    'rating': rating,
                    'interaction_type': interaction_type,
                    'timestamp': datetime.now() - timedelta(days=random.randint(1, 365))
                })
        
        df = pd.DataFrame(interactions)
        df.to_csv(f"{self.output_dir}/recommendation_data.csv", index=False)
        print(f"✅ 推荐系统数据已保存到 {self.output_dir}/recommendation_data.csv")
        
        return df
    
    def generate_all_ai_test_data(self):
        """生成所有AI测试数据"""
        print("🤖 开始生成AI功能测试数据集...")
        
        try:
            self.generate_sales_trend_data()
            self.generate_customer_churn_data()
            self.generate_sentiment_analysis_data()
            self.generate_recommendation_data()
            
            print("✅ 所有AI测试数据生成完成！")
            print(f"📁 数据保存在目录: {self.output_dir}")
            
        except Exception as e:
            print(f"❌ 生成AI测试数据时出错: {e}")

if __name__ == "__main__":
    generator = AITestDataGenerator()
    generator.generate_all_ai_test_data()
```

### 4. 性能测试数据脚本

```bash
#!/bin/bash
# scripts/generate_performance_test_data.sh
# 性能测试数据生成脚本

echo "🚀 开始生成性能测试数据..."

# 加载环境变量
source .env

# 生成大量测试数据
echo "📊 生成大量测试数据..."
python3 scripts/generate_test_data.py

echo "🤖 生成AI功能测试数据..."
python3 scripts/generate_ai_test_data.py

# 生成压力测试用户
echo "👥 生成压力测试用户..."
python3 << 'EOF'
import psycopg2
import os

DATABASE_URL = os.getenv('DATABASE_URL')
conn = psycopg2.connect(DATABASE_URL)
cursor = conn.cursor()

# 生成1000个测试用户用于并发测试
users_data = []
for i in range(1000):
    username = f"perf_test_user_{i+1:04d}"
    password = '$2a$10$N.zmdr9k7uOCQb376NoUnuTJ8iAt6Z5EHsM7lbqxrDB3gF.eZBJvG'
    name = f"性能测试用户{i+1}"
    phone = f"139{i+1:08d}"
    
    users_data.append((username, password, name, phone, 2, 3, 1))

insert_sql = """
INSERT INTO users (username, password, name, phone, department_id, role_id, status, created_at, updated_at)
VALUES (%s, %s, %s, %s, %s, %s, %s, NOW(), NOW())
ON CONFLICT (username) DO NOTHING
"""

cursor.executemany(insert_sql, users_data)
conn.commit()

print(f"✅ 生成了 {len(users_data)} 个性能测试用户")

cursor.close()
conn.close()
EOF

# 创建测试数据清理脚本
echo "🧹 创建数据清理脚本..."
cat > scripts/cleanup_test_data.sql << 'EOF'
-- 清理测试数据脚本
-- 注意：仅清理测试数据，保留基础配置数据

-- 清理业务测试数据
DELETE FROM tracking_records WHERE created_by IN (SELECT id FROM users WHERE username LIKE 'test_%' OR username LIKE 'perf_test_%');
DELETE FROM payments WHERE order_id IN (SELECT id FROM orders WHERE assigned_user_id IN (SELECT id FROM users WHERE username LIKE 'test_%' OR username LIKE 'perf_test_%'));
DELETE FROM orders WHERE assigned_user_id IN (SELECT id FROM users WHERE username LIKE 'test_%' OR username LIKE 'perf_test_%');
DELETE FROM customers WHERE assigned_user_id IN (SELECT id FROM users WHERE username LIKE 'test_%' OR username LIKE 'perf_test_%');
DELETE FROM leads WHERE assigned_user_id IN (SELECT id FROM users WHERE username LIKE 'test_%' OR username LIKE 'perf_test_%');

-- 清理测试用户
DELETE FROM users WHERE username LIKE 'test_%' OR username LIKE 'perf_test_%';

-- 清理测试活动
DELETE FROM campaign_daily_stats WHERE campaign_id IN (SELECT id FROM campaigns WHERE name LIKE '%测试%');
DELETE FROM campaigns WHERE name LIKE '%测试%';

-- 重置序列
SELECT setval('users_id_seq', (SELECT MAX(id) FROM users));
SELECT setval('leads_id_seq', (SELECT MAX(id) FROM leads));
SELECT setval('customers_id_seq', (SELECT MAX(id) FROM customers));
SELECT setval('orders_id_seq', (SELECT MAX(id) FROM orders));
SELECT setval('campaigns_id_seq', (SELECT MAX(id) FROM campaigns));

COMMIT;
EOF

echo "✅ 性能测试数据生成完成！"
echo "📋 生成的数据包括："
echo "  - 大量业务测试数据（线索、客户、订单等）"
echo "  - 1000个性能测试用户账户"
echo "  - AI功能测试数据集"
echo "  - 数据清理脚本"
echo ""
echo "🔧 使用方法："
echo "  1. 运行性能测试前先执行此脚本"
echo "  2. 测试完成后运行: psql \$DATABASE_URL -f scripts/cleanup_test_data.sql"
```

### 5. 测试工具和脚本

```python
# scripts/test_data_validator.py
"""
测试数据验证脚本
"""

import psycopg2
import os
from datetime import datetime

class TestDataValidator:
    def __init__(self):
        self.conn = psycopg2.connect(os.getenv('DATABASE_URL'))
        self.cursor = self.conn.cursor()
    
    def validate_data_integrity(self):
        """验证数据完整性"""
        print("🔍 验证数据完整性...")
        
        checks = [
            {
                'name': '用户数据完整性',
                'sql': "SELECT COUNT(*) FROM users WHERE username IS NULL OR password IS NULL OR name IS NULL"
            },
            {
                'name': '线索分配完整性',
                'sql': "SELECT COUNT(*) FROM leads WHERE assigned_user_id NOT IN (SELECT id FROM users WHERE status = 1)"
            },
            {
                'name': '客户订单关联完整性',
                'sql': "SELECT COUNT(*) FROM orders WHERE customer_id NOT IN (SELECT id FROM customers WHERE status IN (1,2,3))"
            },
            {
                'name': '支付订单关联完整性',
                'sql': "SELECT COUNT(*) FROM payments WHERE order_id NOT IN (SELECT id FROM orders)"
            },
            {
                'name': '跟踪记录关联完整性',
                'sql': """
                SELECT COUNT(*) FROM tracking_records 
                WHERE (lead_id IS NOT NULL AND lead_id NOT IN (SELECT id FROM leads))
                   OR (customer_id IS NOT NULL AND customer_id NOT IN (SELECT id FROM customers))
                """
            }
        ]
        
        all_passed = True
        for check in checks:
            self.cursor.execute(check['sql'])
            result = self.cursor.fetchone()[0]
            
            if result == 0:
                print(f"  ✅ {check['name']}: 通过")
            else:
                print(f"  ❌ {check['name']}: 发现 {result} 条异常数据")
                all_passed = False
        
        return all_passed
    
    def validate_business_rules(self):
        """验证业务规则"""
        print("📋 验证业务规则...")
        
        rules = [
            {
                'name': '订单金额一致性',
                'sql': "SELECT COUNT(*) FROM orders WHERE total_amount != unit_price * quantity"
            },
            {
                'name': '支付金额合理性',
                'sql': "SELECT COUNT(*) FROM payments p JOIN orders o ON p.order_id = o.id WHERE p.payment_amount > o.total_amount"
            },
            {
                'name': '客户状态合理性',
                'sql': "SELECT COUNT(*) FROM customers WHERE status = 3 AND total_order_amount = 0"
            },
            {
                'name': '线索转化状态',
                'sql': "SELECT COUNT(*) FROM leads WHERE status = 3 AND id NOT IN (SELECT source_lead_id FROM customers WHERE source_lead_id IS NOT NULL)"
            }
        ]
        
        all_passed = True
        for rule in rules:
            self.cursor.execute(rule['sql'])
            result = self.cursor.fetchone()[0]
            
            if result == 0:
                print(f"  ✅ {rule['name']}: 通过")
            else:
                print(f"  ⚠️ {rule['name']}: 发现 {result} 条可能异常的数据")
                all_passed = False
        
        return all_passed
    
    def generate_data_report(self):
        """生成数据报告"""
        print("📊 生成数据统计报告...")
        
        report = []
        
        # 基础数据统计
        tables = [
            ('users', '用户'),
            ('departments', '部门'),
            ('roles', '角色'),
            ('leads', '线索'),
            ('customers', '客户'),
            ('orders', '订单'),
            ('payments', '支付记录'),
            ('tracking_records', '跟踪记录'),
            ('campaigns', '推广活动'),
            ('operation_logs', '操作日志')
        ]
        
        for table, name in tables:
            self.cursor.execute(f"SELECT COUNT(*) FROM {table}")
            count = self.cursor.fetchone()[0]
            report.append(f"{name}: {count:,} 条")
        
        # 业务数据分析
        self.cursor.execute("""
        SELECT 
            l.status,
            CASE 
                WHEN l.status = 1 THEN '待跟进'
                WHEN l.status = 2 THEN '跟进中'
                WHEN l.status = 3 THEN '已转化'
                WHEN l.status = 4 THEN '无效'
            END as status_name,
            COUNT(*) as count
        FROM leads l
        GROUP BY l.status
        ORDER BY l.status
        """)
        
        lead_stats = self.cursor.fetchall()
        report.append("\n线索状态分布:")
        for stat in lead_stats:
            report.append(f"  {stat[1]}: {stat[2]:,} 条")
        
        # 客户状态分析
        self.cursor.execute("""
        SELECT 
            c.status,
            CASE 
                WHEN c.status = 1 THEN '潜在客户'
                WHEN c.status = 2 THEN '跟进中'
                WHEN c.status = 3 THEN '已成单'
                WHEN c.status = 4 THEN '流失'
            END as status_name,
            COUNT(*) as count,
            COALESCE(SUM(c.total_order_amount), 0) as total_amount
        FROM customers c
        GROUP BY c.status
        ORDER BY c.status
        """)
        
        customer_stats = self.cursor.fetchall()
        report.append("\n客户状态分布:")
        for stat in customer_stats:
            report.append(f"  {stat[1]}: {stat[2]:,} 条, 总金额: ¥{stat[3]:,.2f}")
        
        # 订单状态分析
        self.cursor.execute("""
        SELECT 
            o.status,
            CASE 
                WHEN o.status = 1 THEN '待确认'
                WHEN o.status = 2 THEN '已确认'
                WHEN o.status = 3 THEN '待付款'
                WHEN o.status = 4 THEN '进行中'
                WHEN o.status = 5 THEN '已完成'
                WHEN o.status = 6 THEN '已取消'
            END as status_name,
            COUNT(*) as count,
            COALESCE(SUM(o.total_amount), 0) as total_amount
        FROM orders o
        GROUP BY o.status
        ORDER BY o.status
        """)
        
        order_stats = self.cursor.fetchall()
        report.append("\n订单状态分布:")
        for stat in order_stats:
            report.append(f"  {stat[1]}: {stat[2]:,} 条, 总金额: ¥{stat[3]:,.2f}")
        
        # 保存报告
        report_content = "\n".join(report)
        
        with open(f"test_data_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt", 'w', encoding='utf-8') as f:
            f.write(f"CRM系统测试数据报告\n")
            f.write(f"生成时间: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write("=" * 50 + "\n\n")
            f.write(report_content)
        
        print(report_content)
        print(f"\n📄 详细报告已保存到文件")
    
    def run_all_validations(self):
        """运行所有验证"""
        print("🔍 开始验证测试数据...")
        
        integrity_passed = self.validate_data_integrity()
        business_passed = self.validate_business_rules()
        
        if integrity_passed and business_passed:
            print("\n✅ 所有验证通过，测试数据质量良好")
        else:
            print("\n⚠️ 发现数据问题，请检查上述异常项")
        
        self.generate_data_report()
        
        self.cursor.close()
        self.conn.close()

if __name__ == "__main__":
    validator = TestDataValidator()
    validator.run_all_validations()
```

<function_calls>
<invoke name="todo_write">
<parameter name="merge">true
