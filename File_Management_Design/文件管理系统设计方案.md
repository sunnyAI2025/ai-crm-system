# CRM系统文件管理设计方案

## 概述

本文档详细设计CRM系统的文件管理模块，包括文件上传、存储、访问控制、图片处理、备份策略和安全机制，为系统提供完整的文件服务能力。

## 文件管理架构

### 1. 整体架构设计

```
┌─────────────────────────────────────────────────────────────────┐
│                    CRM文件管理架构图                              │
├─────────────────────────────────────────────────────────────────┤
│  前端文件组件 ←─→ API网关 ←─→ 文件服务 ←─→ 存储系统               │
│       ↓              ↓         ↓            ↓                   │
│  ┌──────────┐   ┌──────────┐ ┌──────────┐ ┌──────────────┐      │
│  │ 上传组件  │   │ 权限验证  │ │ 文件处理  │ │ 本地存储      │      │
│  │ 预览组件  │   │ 路由转发  │ │ 格式转换  │ │ 云端存储      │      │
│  │ 管理组件  │   │ 限流控制  │ │ 压缩优化  │ │ CDN分发      │      │
│  └──────────┘   └──────────┘ └──────────┘ └──────────────┘      │
│       ↓              ↓         ↓            ↓                   │
│  ┌──────────┐   ┌──────────┐ ┌──────────┐ ┌──────────────┐      │
│  │ 拖拽上传  │   │ JWT验证  │ │ 病毒扫描  │ │ 文件去重      │      │
│  │ 进度显示  │   │ 权限检查  │ │ 水印添加  │ │ 版本控制      │      │
│  │ 批量操作  │   │ 频次限制  │ │ 缩略图   │ │ 定期备份      │      │
│  └──────────┘   └──────────┘ └──────────┘ └──────────────┘      │
└─────────────────────────────────────────────────────────────────┘
```

### 2. 核心服务组件

#### 2.1 文件服务层
- **文件上传服务**: 处理各类文件上传请求
- **文件下载服务**: 提供安全的文件下载功能
- **图片处理服务**: 图片压缩、格式转换、缩略图生成
- **文件管理服务**: 文件元数据管理、版本控制

#### 2.2 存储策略层
- **本地存储**: 临时文件和系统关键文件
- **云端存储**: 用户数据和备份文件
- **CDN分发**: 静态资源和公共文件
- **缓存策略**: 热点文件和缩略图缓存

#### 2.3 安全控制层
- **访问权限控制**: 基于角色的文件访问权限
- **文件内容验证**: 文件类型、病毒扫描、内容检查
- **传输安全**: HTTPS传输、文件加密存储
- **审计日志**: 文件操作的完整记录

## 文件类型和规范

### 1. 支持的文件类型

#### 1.1 图片文件
```javascript
const IMAGE_TYPES = {
  avatar: {
    extensions: ['.jpg', '.jpeg', '.png', '.webp'],
    maxSize: 5 * 1024 * 1024, // 5MB
    dimensions: {
      min: { width: 100, height: 100 },
      max: { width: 2000, height: 2000 }
    },
    quality: 85,
    formats: ['jpg', 'webp'] // 输出格式
  },
  document_image: {
    extensions: ['.jpg', '.jpeg', '.png', '.gif', '.bmp'],
    maxSize: 10 * 1024 * 1024, // 10MB
    dimensions: {
      max: { width: 4000, height: 4000 }
    },
    quality: 90
  }
};
```

#### 1.2 文档文件
```javascript
const DOCUMENT_TYPES = {
  general: {
    extensions: ['.pdf', '.doc', '.docx', '.xls', '.xlsx', '.ppt', '.pptx'],
    maxSize: 50 * 1024 * 1024, // 50MB
    previewSupport: true,
    versionControl: true
  },
  contract: {
    extensions: ['.pdf', '.doc', '.docx'],
    maxSize: 20 * 1024 * 1024, // 20MB
    encryption: true,
    watermark: true,
    auditRequired: true
  },
  report: {
    extensions: ['.pdf', '.xls', '.xlsx', '.csv'],
    maxSize: 30 * 1024 * 1024, // 30MB
    autoBackup: true,
    versionControl: true
  }
};
```

#### 1.3 压缩文件
```javascript
const ARCHIVE_TYPES = {
  backup: {
    extensions: ['.zip', '.rar', '.7z'],
    maxSize: 100 * 1024 * 1024, // 100MB
    scanRequired: true,
    quarantine: true
  }
};
```

### 2. 文件命名规范

#### 2.1 文件命名策略
```javascript
const FILE_NAMING = {
  // 头像文件: avatar_{userId}_{timestamp}.{ext}
  avatar: (userId, timestamp, ext) => `avatar_${userId}_${timestamp}.${ext}`,
  
  // 文档文件: doc_{type}_{userId}_{timestamp}_{hash}.{ext}
  document: (type, userId, timestamp, hash, ext) => 
    `doc_${type}_${userId}_${timestamp}_${hash.substring(0, 8)}.${ext}`,
  
  // 报告文件: report_{reportType}_{date}_{version}.{ext}
  report: (reportType, date, version, ext) => 
    `report_${reportType}_${date}_v${version}.${ext}`,
  
  // 临时文件: temp_{sessionId}_{timestamp}.{ext}
  temporary: (sessionId, timestamp, ext) => `temp_${sessionId}_${timestamp}.${ext}`
};
```

#### 2.2 目录结构规范
```
/uploads/
├── avatars/           # 用户头像
│   ├── 2024/
│   └── thumbnails/    # 缩略图
├── documents/         # 一般文档
│   ├── contracts/     # 合同文件
│   ├── reports/       # 报告文件
│   └── temp/          # 临时文件
├── images/            # 图片资源
│   ├── products/      # 产品图片
│   └── marketing/     # 营销素材
└── backups/           # 备份文件
    ├── daily/
    └── weekly/
```

## 数据库设计

### 1. 文件表结构扩展

```sql
-- 文件表（扩展版本）
CREATE TABLE files (
    id BIGSERIAL PRIMARY KEY,
    -- 基本信息
    original_name VARCHAR(255) NOT NULL COMMENT '原始文件名',
    file_name VARCHAR(255) NOT NULL COMMENT '存储文件名',
    file_path VARCHAR(500) NOT NULL COMMENT '文件相对路径',
    file_url VARCHAR(1000) COMMENT '文件访问URL',
    
    -- 文件属性
    file_size BIGINT NOT NULL COMMENT '文件大小(字节)',
    file_type VARCHAR(50) NOT NULL COMMENT '文件类型分类',
    mime_type VARCHAR(100) NOT NULL COMMENT 'MIME类型',
    file_extension VARCHAR(10) NOT NULL COMMENT '文件扩展名',
    file_hash VARCHAR(64) NOT NULL COMMENT '文件MD5哈希值',
    
    -- 图片属性
    image_width INT COMMENT '图片宽度',
    image_height INT COMMENT '图片高度',
    has_thumbnail SMALLINT DEFAULT 0 COMMENT '是否有缩略图',
    thumbnail_path VARCHAR(500) COMMENT '缩略图路径',
    
    -- 关联信息
    upload_user_id BIGINT NOT NULL COMMENT '上传用户ID',
    reference_type VARCHAR(50) COMMENT '关联类型',
    reference_id BIGINT COMMENT '关联对象ID',
    business_module VARCHAR(50) COMMENT '业务模块',
    
    -- 访问控制
    is_public SMALLINT DEFAULT 0 COMMENT '是否公开',
    access_level VARCHAR(20) DEFAULT 'private' COMMENT '访问级别',
    allowed_roles TEXT COMMENT '允许访问的角色，JSON格式',
    
    -- 版本控制
    version_id VARCHAR(50) COMMENT '版本标识',
    parent_file_id BIGINT COMMENT '父文件ID（版本控制）',
    is_latest_version SMALLINT DEFAULT 1 COMMENT '是否最新版本',
    
    -- 处理状态
    process_status SMALLINT DEFAULT 0 COMMENT '处理状态：0-待处理，1-处理中，2-已完成，3-失败',
    process_result TEXT COMMENT '处理结果信息',
    
    -- 统计信息
    download_count INT DEFAULT 0 COMMENT '下载次数',
    view_count INT DEFAULT 0 COMMENT '查看次数',
    last_access_time TIMESTAMP COMMENT '最后访问时间',
    
    -- 安全信息
    is_encrypted SMALLINT DEFAULT 0 COMMENT '是否加密',
    encryption_algorithm VARCHAR(50) COMMENT '加密算法',
    virus_scan_status SMALLINT DEFAULT 0 COMMENT '病毒扫描状态',
    virus_scan_result TEXT COMMENT '扫描结果',
    
    -- 标准字段
    status SMALLINT DEFAULT 1 COMMENT '状态：1-正常，0-删除',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '更新时间'
);

-- 文件访问日志表
CREATE TABLE file_access_logs (
    id BIGSERIAL PRIMARY KEY,
    file_id BIGINT NOT NULL COMMENT '文件ID',
    user_id BIGINT COMMENT '访问用户ID',
    access_type VARCHAR(20) NOT NULL COMMENT '访问类型：view, download, upload, delete',
    ip_address VARCHAR(50) COMMENT 'IP地址',
    user_agent TEXT COMMENT '用户代理',
    access_result VARCHAR(20) DEFAULT 'success' COMMENT '访问结果：success, failed, denied',
    error_message TEXT COMMENT '错误信息',
    access_duration INT COMMENT '访问耗时（毫秒）',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '访问时间'
);

-- 文件分享表
CREATE TABLE file_shares (
    id BIGSERIAL PRIMARY KEY,
    file_id BIGINT NOT NULL COMMENT '文件ID',
    share_user_id BIGINT NOT NULL COMMENT '分享用户ID',
    share_token VARCHAR(100) NOT NULL COMMENT '分享令牌',
    share_password VARCHAR(100) COMMENT '分享密码',
    expire_time TIMESTAMP COMMENT '过期时间',
    max_download_count INT COMMENT '最大下载次数',
    current_download_count INT DEFAULT 0 COMMENT '当前下载次数',
    is_public SMALLINT DEFAULT 0 COMMENT '是否公开分享',
    status SMALLINT DEFAULT 1 COMMENT '状态：1-有效，0-失效',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间'
);

-- 文件标签表
CREATE TABLE file_tags (
    id BIGSERIAL PRIMARY KEY,
    file_id BIGINT NOT NULL COMMENT '文件ID',
    tag_name VARCHAR(50) NOT NULL COMMENT '标签名称',
    tag_type VARCHAR(20) DEFAULT 'user' COMMENT '标签类型：user, system, auto',
    created_by BIGINT COMMENT '创建用户ID',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间'
);

-- 创建索引
CREATE INDEX idx_files_hash ON files(file_hash);
CREATE INDEX idx_files_reference ON files(reference_type, reference_id);
CREATE INDEX idx_files_upload_user ON files(upload_user_id);
CREATE INDEX idx_files_type_status ON files(file_type, status);
CREATE INDEX idx_files_created_at ON files(created_at);

CREATE INDEX idx_file_access_logs_file_id ON file_access_logs(file_id);
CREATE INDEX idx_file_access_logs_user_id ON file_access_logs(user_id);
CREATE INDEX idx_file_access_logs_created_at ON file_access_logs(created_at);

CREATE INDEX idx_file_shares_token ON file_shares(share_token);
CREATE INDEX idx_file_shares_file_user ON file_shares(file_id, share_user_id);

CREATE INDEX idx_file_tags_file_id ON file_tags(file_id);
CREATE INDEX idx_file_tags_name ON file_tags(tag_name);
```

## 文件上传功能

### 1. 前端上传组件

#### 1.1 通用文件上传组件
```jsx
import React, { useState, useCallback } from 'react';
import { Upload, message, Progress, Modal } from 'antd';
import { InboxOutlined, DeleteOutlined, EyeOutlined } from '@ant-design/icons';

const { Dragger } = Upload;

const FileUploadComponent = ({
  fileType = 'general',
  maxCount = 1,
  showPreview = true,
  onSuccess,
  onError,
  referenceType,
  referenceId,
  accept,
  maxSize = 10 * 1024 * 1024, // 10MB
  ...props
}) => {
  const [fileList, setFileList] = useState([]);
  const [uploading, setUploading] = useState(false);
  const [previewVisible, setPreviewVisible] = useState(false);
  const [previewImage, setPreviewImage] = useState('');
  const [previewTitle, setPreviewTitle] = useState('');

  // 文件上传前的验证
  const beforeUpload = useCallback((file) => {
    // 文件大小验证
    if (file.size > maxSize) {
      message.error(`文件大小不能超过 ${Math.round(maxSize / 1024 / 1024)}MB`);
      return false;
    }

    // 文件类型验证
    const fileExtension = '.' + file.name.split('.').pop().toLowerCase();
    if (accept && !accept.includes(fileExtension)) {
      message.error(`不支持的文件格式，请上传 ${accept.join('、')} 格式的文件`);
      return false;
    }

    // 文件名长度验证
    if (file.name.length > 100) {
      message.error('文件名长度不能超过100个字符');
      return false;
    }

    return true;
  }, [accept, maxSize]);

  // 自定义上传处理
  const customRequest = useCallback(async ({ file, onProgress, onSuccess, onError }) => {
    const formData = new FormData();
    formData.append('file', file);
    formData.append('fileType', fileType);
    if (referenceType) formData.append('referenceType', referenceType);
    if (referenceId) formData.append('referenceId', referenceId);

    try {
      setUploading(true);
      
      const response = await fetch('/api/files/upload', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('token')}`
        },
        body: formData
      });

      if (!response.ok) {
        throw new Error(`上传失败: ${response.statusText}`);
      }

      const result = await response.json();
      
      if (result.code === 0) {
        onSuccess(result.data, file);
        message.success('文件上传成功');
        onSuccess && onSuccess(result.data);
      } else {
        throw new Error(result.message || '上传失败');
      }
    } catch (error) {
      console.error('文件上传错误:', error);
      onError(error, file);
      message.error(error.message || '文件上传失败');
      onError && onError(error);
    } finally {
      setUploading(false);
    }
  }, [fileType, referenceType, referenceId, onSuccess, onError]);

  // 文件状态变化处理
  const handleChange = useCallback(({ fileList: newFileList }) => {
    setFileList(newFileList.map(file => {
      if (file.response && file.response.code === 0) {
        return {
          ...file,
          url: file.response.data.fileUrl,
          status: 'done'
        };
      }
      return file;
    }));
  }, []);

  // 文件预览
  const handlePreview = useCallback(async (file) => {
    if (!file.url && !file.preview) {
      file.preview = await getBase64(file.originFileObj);
    }

    setPreviewImage(file.url || file.preview);
    setPreviewVisible(true);
    setPreviewTitle(file.name || file.url.substring(file.url.lastIndexOf('/') + 1));
  }, []);

  // 文件删除
  const handleRemove = useCallback(async (file) => {
    if (file.response && file.response.data && file.response.data.id) {
      try {
        await fetch(`/api/files/${file.response.data.id}`, {
          method: 'DELETE',
          headers: {
            'Authorization': `Bearer ${localStorage.getItem('token')}`
          }
        });
        message.success('文件删除成功');
      } catch (error) {
        console.error('文件删除失败:', error);
        message.error('文件删除失败');
      }
    }
    return true;
  }, []);

  return (
    <>
      <Dragger
        {...props}
        fileList={fileList}
        beforeUpload={beforeUpload}
        customRequest={customRequest}
        onChange={handleChange}
        onPreview={showPreview ? handlePreview : undefined}
        onRemove={handleRemove}
        maxCount={maxCount}
        multiple={maxCount > 1}
        accept={accept ? accept.join(',') : undefined}
        disabled={uploading}
      >
        <p className="ant-upload-drag-icon">
          <InboxOutlined />
        </p>
        <p className="ant-upload-text">
          点击或拖拽文件到此区域上传
        </p>
        <p className="ant-upload-hint">
          支持单个或批量上传，最大文件大小 {Math.round(maxSize / 1024 / 1024)}MB
        </p>
      </Dragger>

      {/* 图片预览弹窗 */}
      <Modal
        visible={previewVisible}
        title={previewTitle}
        footer={null}
        onCancel={() => setPreviewVisible(false)}
      >
        <img alt="preview" style={{ width: '100%' }} src={previewImage} />
      </Modal>
    </>
  );
};

// 图片转Base64工具函数
const getBase64 = (file) => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () => resolve(reader.result);
    reader.onerror = error => reject(error);
  });
};

export default FileUploadComponent;
```

#### 1.2 头像上传组件
```jsx
import React, { useState } from 'react';
import { Upload, Avatar, message, Modal } from 'antd';
import { UserOutlined, CameraOutlined } from '@ant-design/icons';
import ImgCrop from 'antd-img-crop';

const AvatarUpload = ({ 
  value, 
  onChange, 
  size = 100,
  showEdit = true,
  cropAspect = 1,
  cropShape = 'round'
}) => {
  const [loading, setLoading] = useState(false);

  const beforeUpload = (file) => {
    const isJpgOrPng = file.type === 'image/jpeg' || file.type === 'image/png';
    if (!isJpgOrPng) {
      message.error('只能上传 JPG/PNG 格式的图片');
      return false;
    }
    const isLt5M = file.size / 1024 / 1024 < 5;
    if (!isLt5M) {
      message.error('图片大小不能超过 5MB');
      return false;
    }
    return true;
  };

  const customRequest = async ({ file, onSuccess, onError }) => {
    const formData = new FormData();
    formData.append('file', file);
    formData.append('fileType', 'avatar');
    formData.append('referenceType', 'user_avatar');

    try {
      setLoading(true);
      
      const response = await fetch('/api/files/upload', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('token')}`
        },
        body: formData
      });

      const result = await response.json();
      
      if (result.code === 0) {
        onSuccess(result.data);
        onChange && onChange(result.data.fileUrl);
        message.success('头像上传成功');
      } else {
        throw new Error(result.message);
      }
    } catch (error) {
      onError(error);
      message.error('头像上传失败');
    } finally {
      setLoading(false);
    }
  };

  const uploadButton = (
    <div style={{ 
      width: size, 
      height: size, 
      border: '1px dashed #d9d9d9',
      borderRadius: cropShape === 'round' ? '50%' : '6px',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      cursor: 'pointer',
      position: 'relative'
    }}>
      {loading ? (
        <div>上传中...</div>
      ) : (
        <>
          {value ? (
            <Avatar size={size - 2} src={value} />
          ) : (
            <Avatar size={size - 2} icon={<UserOutlined />} />
          )}
          {showEdit && (
            <div style={{
              position: 'absolute',
              bottom: 0,
              right: 0,
              background: '#1890ff',
              borderRadius: '50%',
              width: 24,
              height: 24,
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center'
            }}>
              <CameraOutlined style={{ color: 'white', fontSize: 12 }} />
            </div>
          )}
        </>
      )}
    </div>
  );

  return (
    <ImgCrop 
      aspect={cropAspect}
      shape={cropShape}
      quality={0.9}
      modalTitle="编辑头像"
      modalOk="确定"
      modalCancel="取消"
    >
      <Upload
        name="avatar"
        listType="picture-card"
        className="avatar-uploader"
        showUploadList={false}
        beforeUpload={beforeUpload}
        customRequest={customRequest}
        disabled={loading}
      >
        {uploadButton}
      </Upload>
    </ImgCrop>
  );
};

export default AvatarUpload;
```

### 2. 后端上传处理

#### 2.1 文件上传控制器
```java
@RestController
@RequestMapping("/api/files")
@RequiresPermission("files")
public class FileController {
    
    @Autowired
    private FileService fileService;
    
    @PostMapping("/upload")
    @RequiresPermission("files:upload")
    public Result<FileInfo> uploadFile(
        @RequestParam("file") MultipartFile file,
        @RequestParam(value = "fileType", defaultValue = "general") String fileType,
        @RequestParam(value = "referenceType", required = false) String referenceType,
        @RequestParam(value = "referenceId", required = false) Long referenceId,
        @RequestParam(value = "isPublic", defaultValue = "false") Boolean isPublic,
        HttpServletRequest request
    ) {
        try {
            // 获取当前用户
            Long userId = SecurityUtils.getUserId();
            String userAgent = request.getHeader("User-Agent");
            String ipAddress = getClientIpAddress(request);
            
            // 创建上传参数
            FileUploadParam uploadParam = FileUploadParam.builder()
                .file(file)
                .fileType(fileType)
                .referenceType(referenceType)
                .referenceId(referenceId)
                .isPublic(isPublic)
                .uploadUserId(userId)
                .userAgent(userAgent)
                .ipAddress(ipAddress)
                .build();
            
            // 执行文件上传
            FileInfo fileInfo = fileService.uploadFile(uploadParam);
            
            return Result.success(fileInfo);
            
        } catch (FileUploadException e) {
            log.error("文件上传失败: {}", e.getMessage(), e);
            return Result.error(e.getMessage());
        } catch (Exception e) {
            log.error("文件上传系统错误", e);
            return Result.error("文件上传失败，请稍后重试");
        }
    }
    
    @GetMapping("/{id}/download")
    @RequiresPermission("files:download")
    public ResponseEntity<Resource> downloadFile(
        @PathVariable Long id,
        HttpServletRequest request,
        HttpServletResponse response
    ) {
        try {
            // 获取文件信息
            FileInfo fileInfo = fileService.getFileInfo(id);
            if (fileInfo == null) {
                throw new FileNotFoundException("文件不存在");
            }
            
            // 检查下载权限
            Long userId = SecurityUtils.getUserId();
            if (!fileService.checkDownloadPermission(userId, fileInfo)) {
                throw new AccessDeniedException("无权下载此文件");
            }
            
            // 获取文件资源
            Resource resource = fileService.getFileResource(fileInfo);
            if (!resource.exists()) {
                throw new FileNotFoundException("文件不存在");
            }
            
            // 记录下载日志
            fileService.recordDownload(userId, fileInfo, getClientIpAddress(request));
            
            // 设置响应头
            String contentType = fileInfo.getMimeType();
            if (contentType == null) {
                contentType = MediaType.APPLICATION_OCTET_STREAM_VALUE;
            }
            
            return ResponseEntity.ok()
                .contentType(MediaType.parseMediaType(contentType))
                .header(HttpHeaders.CONTENT_DISPOSITION, 
                    "attachment; filename=\"" + fileInfo.getOriginalName() + "\"")
                .body(resource);
                
        } catch (FileNotFoundException | AccessDeniedException e) {
            log.warn("文件下载失败: {}", e.getMessage());
            return ResponseEntity.notFound().build();
        } catch (Exception e) {
            log.error("文件下载系统错误", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    @GetMapping("/{id}")
    @RequiresPermission("files:view")
    public Result<FileInfo> getFileInfo(@PathVariable Long id) {
        try {
            FileInfo fileInfo = fileService.getFileInfo(id);
            if (fileInfo == null) {
                return Result.error("文件不存在");
            }
            
            // 检查查看权限
            Long userId = SecurityUtils.getUserId();
            if (!fileService.checkViewPermission(userId, fileInfo)) {
                return Result.error("无权查看此文件");
            }
            
            // 记录查看日志
            fileService.recordView(userId, fileInfo, getClientIpAddress(request));
            
            return Result.success(fileInfo);
            
        } catch (Exception e) {
            log.error("获取文件信息失败", e);
            return Result.error("获取文件信息失败");
        }
    }
    
    @DeleteMapping("/{id}")
    @RequiresPermission("files:delete")
    public Result<Void> deleteFile(@PathVariable Long id, HttpServletRequest request) {
        try {
            // 获取当前用户
            Long userId = SecurityUtils.getUserId();
            
            // 检查删除权限
            if (!fileService.checkDeletePermission(userId, id)) {
                return Result.error("无权删除此文件");
            }
            
            // 执行删除
            fileService.deleteFile(id, userId, getClientIpAddress(request));
            
            return Result.success();
            
        } catch (Exception e) {
            log.error("删除文件失败", e);
            return Result.error("删除文件失败");
        }
    }
    
    private String getClientIpAddress(HttpServletRequest request) {
        String ip = request.getHeader("X-Forwarded-For");
        if (ip == null || ip.isEmpty() || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("Proxy-Client-IP");
        }
        if (ip == null || ip.isEmpty() || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("WL-Proxy-Client-IP");
        }
        if (ip == null || ip.isEmpty() || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getRemoteAddr();
        }
        return ip;
    }
}
```

#### 2.2 文件服务实现
```java
@Service
public class FileService {
    
    @Autowired
    private FileMapper fileMapper;
    
    @Autowired
    private FileAccessLogMapper accessLogMapper;
    
    @Autowired
    private FileStorageService storageService;
    
    @Autowired
    private ImageProcessingService imageService;
    
    @Autowired
    private FileSecurityService securityService;
    
    @Value("${file.upload.base-path}")
    private String uploadBasePath;
    
    @Value("${file.upload.max-size}")
    private long maxFileSize;
    
    public FileInfo uploadFile(FileUploadParam param) throws FileUploadException {
        MultipartFile file = param.getFile();
        
        // 1. 基础验证
        validateFile(file, param.getFileType());
        
        // 2. 安全检查
        securityService.scanFile(file);
        
        // 3. 计算文件哈希
        String fileHash = calculateFileHash(file);
        
        // 4. 检查文件去重
        FileInfo existingFile = fileMapper.findByHash(fileHash);
        if (existingFile != null && param.isDeduplication()) {
            return createFileReference(existingFile, param);
        }
        
        // 5. 生成文件名和路径
        String fileName = generateFileName(file, param);
        String filePath = generateFilePath(fileName, param.getFileType());
        
        // 6. 保存文件到存储系统
        String savedPath = storageService.saveFile(file, filePath);
        
        // 7. 处理图片文件
        FileProcessResult processResult = null;
        if (isImageFile(file)) {
            processResult = imageService.processImage(savedPath, param);
        }
        
        // 8. 保存文件记录
        FileInfo fileInfo = createFileRecord(file, param, fileName, savedPath, fileHash, processResult);
        fileMapper.insert(fileInfo);
        
        // 9. 异步处理文件（缩略图、水印等）
        asyncProcessFile(fileInfo);
        
        // 10. 记录上传日志
        recordUpload(param.getUploadUserId(), fileInfo, param.getIpAddress());
        
        return fileInfo;
    }
    
    private void validateFile(MultipartFile file, String fileType) throws FileUploadException {
        if (file.isEmpty()) {
            throw new FileUploadException("文件不能为空");
        }
        
        if (file.getSize() > maxFileSize) {
            throw new FileUploadException("文件大小不能超过 " + (maxFileSize / 1024 / 1024) + "MB");
        }
        
        String originalFilename = file.getOriginalFilename();
        if (originalFilename == null || originalFilename.length() > 255) {
            throw new FileUploadException("文件名不合法");
        }
        
        String extension = getFileExtension(originalFilename);
        if (!isAllowedExtension(extension, fileType)) {
            throw new FileUploadException("不支持的文件格式: " + extension);
        }
    }
    
    private String calculateFileHash(MultipartFile file) throws FileUploadException {
        try {
            MessageDigest md = MessageDigest.getInstance("MD5");
            byte[] digest = md.digest(file.getBytes());
            return DatatypeConverter.printHexBinary(digest).toLowerCase();
        } catch (Exception e) {
            throw new FileUploadException("计算文件哈希失败", e);
        }
    }
    
    private String generateFileName(MultipartFile file, FileUploadParam param) {
        String extension = getFileExtension(file.getOriginalFilename());
        String timestamp = String.valueOf(System.currentTimeMillis());
        String randomStr = RandomStringUtils.randomAlphanumeric(8);
        
        switch (param.getFileType()) {
            case "avatar":
                return String.format("avatar_%d_%s.%s", 
                    param.getUploadUserId(), timestamp, extension);
            case "document":
                return String.format("doc_%s_%d_%s_%s.%s", 
                    param.getReferenceType(), param.getUploadUserId(), timestamp, randomStr, extension);
            default:
                return String.format("file_%s_%s.%s", timestamp, randomStr, extension);
        }
    }
    
    private String generateFilePath(String fileName, String fileType) {
        LocalDate now = LocalDate.now();
        String datePath = now.format(DateTimeFormatter.ofPattern("yyyy/MM/dd"));
        
        switch (fileType) {
            case "avatar":
                return String.format("avatars/%s/%s", datePath, fileName);
            case "document":
                return String.format("documents/%s/%s", datePath, fileName);
            case "image":
                return String.format("images/%s/%s", datePath, fileName);
            default:
                return String.format("general/%s/%s", datePath, fileName);
        }
    }
    
    private FileInfo createFileRecord(
        MultipartFile file, 
        FileUploadParam param, 
        String fileName, 
        String savedPath, 
        String fileHash,
        FileProcessResult processResult
    ) {
        FileInfo fileInfo = new FileInfo();
        fileInfo.setOriginalName(file.getOriginalFilename());
        fileInfo.setFileName(fileName);
        fileInfo.setFilePath(savedPath);
        fileInfo.setFileUrl(storageService.getFileUrl(savedPath));
        fileInfo.setFileSize(file.getSize());
        fileInfo.setFileType(param.getFileType());
        fileInfo.setMimeType(file.getContentType());
        fileInfo.setFileExtension(getFileExtension(file.getOriginalFilename()));
        fileInfo.setFileHash(fileHash);
        fileInfo.setUploadUserId(param.getUploadUserId());
        fileInfo.setReferenceType(param.getReferenceType());
        fileInfo.setReferenceId(param.getReferenceId());
        fileInfo.setIsPublic(param.isPublic() ? 1 : 0);
        fileInfo.setVersionId(UUID.randomUUID().toString());
        
        if (processResult != null) {
            fileInfo.setImageWidth(processResult.getWidth());
            fileInfo.setImageHeight(processResult.getHeight());
            fileInfo.setHasThumbnail(processResult.hasThumbnail() ? 1 : 0);
            fileInfo.setThumbnailPath(processResult.getThumbnailPath());
        }
        
        return fileInfo;
    }
    
    @Async
    public void asyncProcessFile(FileInfo fileInfo) {
        try {
            if (isImageFile(fileInfo)) {
                // 生成缩略图
                imageService.generateThumbnail(fileInfo);
                
                // 添加水印（如果需要）
                if (needsWatermark(fileInfo)) {
                    imageService.addWatermark(fileInfo);
                }
            }
            
            // 文件病毒扫描
            securityService.asyncVirusScan(fileInfo);
            
            // 更新处理状态
            fileInfo.setProcessStatus(2); // 已完成
            fileMapper.updateById(fileInfo);
            
        } catch (Exception e) {
            log.error("异步处理文件失败: {}", fileInfo.getId(), e);
            fileInfo.setProcessStatus(3); // 失败
            fileInfo.setProcessResult(e.getMessage());
            fileMapper.updateById(fileInfo);
        }
    }
    
    public boolean checkDownloadPermission(Long userId, FileInfo fileInfo) {
        // 公开文件允许下载
        if (fileInfo.getIsPublic() == 1) {
            return true;
        }
        
        // 文件上传者可以下载
        if (Objects.equals(userId, fileInfo.getUploadUserId())) {
            return true;
        }
        
        // 检查角色权限
        UserPermissionContext context = SecurityUtils.getUserPermissionContext();
        
        // 系统管理员可以下载所有文件
        if (context.hasPermission("files:admin")) {
            return true;
        }
        
        // 根据文件关联类型检查权限
        return checkBusinessPermission(userId, fileInfo, "download");
    }
    
    private boolean checkBusinessPermission(Long userId, FileInfo fileInfo, String operation) {
        String referenceType = fileInfo.getReferenceType();
        Long referenceId = fileInfo.getReferenceId();
        
        if (referenceType == null || referenceId == null) {
            return false;
        }
        
        switch (referenceType) {
            case "user_avatar":
                // 用户头像：本人和管理员可访问
                return Objects.equals(userId, referenceId) || 
                       SecurityUtils.hasPermission("system:users:view");
                       
            case "lead_document":
                // 线索文档：分配给用户或其主管可访问
                return leadService.hasAccessPermission(userId, referenceId);
                
            case "customer_document":
                // 客户文档：客户负责人或其主管可访问
                return customerService.hasAccessPermission(userId, referenceId);
                
            case "order_contract":
                // 订单合同：订单相关人员可访问
                return orderService.hasAccessPermission(userId, referenceId);
                
            default:
                return false;
        }
    }
    
    public void recordDownload(Long userId, FileInfo fileInfo, String ipAddress) {
        FileAccessLog log = new FileAccessLog();
        log.setFileId(fileInfo.getId());
        log.setUserId(userId);
        log.setAccessType("download");
        log.setIpAddress(ipAddress);
        log.setAccessResult("success");
        accessLogMapper.insert(log);
        
        // 更新下载统计
        fileMapper.incrementDownloadCount(fileInfo.getId());
    }
}
```

## 图片处理功能

### 1. 图片处理服务

#### 1.1 图片处理核心类
```java
@Service
public class ImageProcessingService {
    
    @Value("${image.thumbnail.enabled:true}")
    private boolean thumbnailEnabled;
    
    @Value("${image.thumbnail.sizes}")
    private String thumbnailSizes;
    
    @Value("${image.watermark.enabled:false}")
    private boolean watermarkEnabled;
    
    @Value("${image.watermark.text}")
    private String watermarkText;
    
    public FileProcessResult processImage(String imagePath, FileUploadParam param) {
        try {
            BufferedImage originalImage = ImageIO.read(new File(imagePath));
            
            FileProcessResult result = new FileProcessResult();
            result.setWidth(originalImage.getWidth());
            result.setHeight(originalImage.getHeight());
            
            // 图片压缩优化
            if (needsCompression(originalImage, param)) {
                compressImage(imagePath, originalImage, param);
            }
            
            // 生成缩略图
            if (thumbnailEnabled && needsThumbnail(param)) {
                String thumbnailPath = generateThumbnail(imagePath, originalImage, param);
                result.setThumbnailPath(thumbnailPath);
                result.setHasThumbnail(true);
            }
            
            return result;
            
        } catch (Exception e) {
            log.error("图片处理失败: {}", imagePath, e);
            throw new ImageProcessingException("图片处理失败", e);
        }
    }
    
    private boolean needsCompression(BufferedImage image, FileUploadParam param) {
        // 头像类型的图片进行压缩
        if ("avatar".equals(param.getFileType())) {
            return true;
        }
        
        // 大尺寸图片进行压缩
        if (image.getWidth() > 2000 || image.getHeight() > 2000) {
            return true;
        }
        
        return false;
    }
    
    private void compressImage(String imagePath, BufferedImage originalImage, FileUploadParam param) {
        try {
            // 根据文件类型设置压缩参数
            float quality = getCompressionQuality(param.getFileType());
            int maxWidth = getMaxWidth(param.getFileType());
            int maxHeight = getMaxHeight(param.getFileType());
            
            // 计算新尺寸
            Dimension newSize = calculateNewSize(
                originalImage.getWidth(), 
                originalImage.getHeight(), 
                maxWidth, 
                maxHeight
            );
            
            // 压缩图片
            BufferedImage compressedImage = Scalr.resize(
                originalImage,
                Scalr.Method.QUALITY,
                Scalr.Mode.FIT_EXACT,
                newSize.width,
                newSize.height
            );
            
            // 保存压缩后的图片
            saveCompressedImage(compressedImage, imagePath, quality);
            
        } catch (Exception e) {
            log.error("图片压缩失败: {}", imagePath, e);
        }
    }
    
    private String generateThumbnail(String imagePath, BufferedImage originalImage, FileUploadParam param) {
        try {
            // 解析缩略图尺寸配置
            String[] sizes = thumbnailSizes.split(",");
            String thumbnailPath = null;
            
            for (String sizeStr : sizes) {
                String[] dimensions = sizeStr.trim().split("x");
                int width = Integer.parseInt(dimensions[0]);
                int height = Integer.parseInt(dimensions[1]);
                
                // 生成缩略图
                BufferedImage thumbnail = Scalr.resize(
                    originalImage,
                    Scalr.Method.QUALITY,
                    Scalr.Mode.FIT_EXACT,
                    width,
                    height
                );
                
                // 保存缩略图
                String thumbPath = generateThumbnailPath(imagePath, width, height);
                ImageIO.write(thumbnail, "jpg", new File(thumbPath));
                
                if (thumbnailPath == null) {
                    thumbnailPath = thumbPath; // 返回第一个尺寸的路径
                }
            }
            
            return thumbnailPath;
            
        } catch (Exception e) {
            log.error("生成缩略图失败: {}", imagePath, e);
            return null;
        }
    }
    
    public void addWatermark(FileInfo fileInfo) {
        try {
            String imagePath = getFullPath(fileInfo.getFilePath());
            BufferedImage originalImage = ImageIO.read(new File(imagePath));
            
            Graphics2D g2d = originalImage.createGraphics();
            
            // 设置水印样式
            g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
            g2d.setFont(new Font("Arial", Font.BOLD, 20));
            g2d.setColor(new Color(255, 255, 255, 128)); // 半透明白色
            
            // 计算水印位置
            FontMetrics fontMetrics = g2d.getFontMetrics();
            int textWidth = fontMetrics.stringWidth(watermarkText);
            int textHeight = fontMetrics.getHeight();
            
            int x = originalImage.getWidth() - textWidth - 10;
            int y = originalImage.getHeight() - textHeight + 10;
            
            // 绘制水印
            g2d.drawString(watermarkText, x, y);
            g2d.dispose();
            
            // 保存带水印的图片
            ImageIO.write(originalImage, "jpg", new File(imagePath));
            
        } catch (Exception e) {
            log.error("添加水印失败: {}", fileInfo.getId(), e);
        }
    }
    
    private float getCompressionQuality(String fileType) {
        switch (fileType) {
            case "avatar":
                return 0.85f;
            case "document_image":
                return 0.90f;
            default:
                return 0.80f;
        }
    }
    
    private int getMaxWidth(String fileType) {
        switch (fileType) {
            case "avatar":
                return 500;
            case "document_image":
                return 1500;
            default:
                return 1200;
        }
    }
    
    private int getMaxHeight(String fileType) {
        switch (fileType) {
            case "avatar":
                return 500;
            case "document_image":
                return 1500;
            default:
                return 1200;
        }
    }
    
    private Dimension calculateNewSize(int originalWidth, int originalHeight, int maxWidth, int maxHeight) {
        if (originalWidth <= maxWidth && originalHeight <= maxHeight) {
            return new Dimension(originalWidth, originalHeight);
        }
        
        double widthRatio = (double) maxWidth / originalWidth;
        double heightRatio = (double) maxHeight / originalHeight;
        double ratio = Math.min(widthRatio, heightRatio);
        
        int newWidth = (int) (originalWidth * ratio);
        int newHeight = (int) (originalHeight * ratio);
        
        return new Dimension(newWidth, newHeight);
    }
    
    private void saveCompressedImage(BufferedImage image, String path, float quality) throws IOException {
        Iterator<ImageWriter> writers = ImageIO.getImageWritersByFormatName("jpg");
        ImageWriter writer = writers.next();
        
        ImageWriteParam param = writer.getDefaultWriteParam();
        param.setCompressionMode(ImageWriteParam.MODE_EXPLICIT);
        param.setCompressionQuality(quality);
        
        FileImageOutputStream output = new FileImageOutputStream(new File(path));
        writer.setOutput(output);
        writer.write(null, new IIOImage(image, null, null), param);
        
        output.close();
        writer.dispose();
    }
    
    private String generateThumbnailPath(String originalPath, int width, int height) {
        String dir = new File(originalPath).getParent();
        String name = FilenameUtils.getBaseName(originalPath);
        String ext = FilenameUtils.getExtension(originalPath);
        
        return String.format("%s/thumbs/%s_%dx%d.%s", dir, name, width, height, ext);
    }
}
```

## 文件存储策略

### 1. 存储服务抽象

#### 1.1 存储服务接口
```java
public interface FileStorageService {
    
    /**
     * 保存文件
     */
    String saveFile(MultipartFile file, String path) throws StorageException;
    
    /**
     * 保存文件（字节数组）
     */
    String saveFile(byte[] data, String path) throws StorageException;
    
    /**
     * 获取文件资源
     */
    Resource getFileResource(String path) throws StorageException;
    
    /**
     * 获取文件URL
     */
    String getFileUrl(String path);
    
    /**
     * 删除文件
     */
    boolean deleteFile(String path);
    
    /**
     * 文件是否存在
     */
    boolean exists(String path);
    
    /**
     * 获取文件大小
     */
    long getFileSize(String path);
    
    /**
     * 复制文件
     */
    String copyFile(String sourcePath, String targetPath) throws StorageException;
    
    /**
     * 移动文件
     */
    String moveFile(String sourcePath, String targetPath) throws StorageException;
}
```

#### 1.2 本地存储实现
```java
@Service
@Profile("local")
public class LocalFileStorageService implements FileStorageService {
    
    @Value("${file.storage.local.base-path}")
    private String basePath;
    
    @Value("${file.storage.local.base-url}")
    private String baseUrl;
    
    @PostConstruct
    public void init() {
        Path uploadPath = Paths.get(basePath);
        if (!Files.exists(uploadPath)) {
            try {
                Files.createDirectories(uploadPath);
            } catch (IOException e) {
                throw new StorageException("无法创建上传目录: " + basePath, e);
            }
        }
    }
    
    @Override
    public String saveFile(MultipartFile file, String path) throws StorageException {
        try {
            if (file.isEmpty()) {
                throw new StorageException("无法保存空文件");
            }
            
            Path targetPath = getTargetPath(path);
            
            // 确保目录存在
            Files.createDirectories(targetPath.getParent());
            
            // 保存文件
            Files.copy(file.getInputStream(), targetPath, StandardCopyOption.REPLACE_EXISTING);
            
            return path;
            
        } catch (IOException e) {
            throw new StorageException("保存文件失败: " + path, e);
        }
    }
    
    @Override
    public String saveFile(byte[] data, String path) throws StorageException {
        try {
            Path targetPath = getTargetPath(path);
            
            // 确保目录存在
            Files.createDirectories(targetPath.getParent());
            
            // 保存文件
            Files.write(targetPath, data, StandardOpenOption.CREATE, StandardOpenOption.WRITE);
            
            return path;
            
        } catch (IOException e) {
            throw new StorageException("保存文件失败: " + path, e);
        }
    }
    
    @Override
    public Resource getFileResource(String path) throws StorageException {
        try {
            Path filePath = getTargetPath(path);
            Resource resource = new UrlResource(filePath.toUri());
            
            if (resource.exists() && resource.isReadable()) {
                return resource;
            } else {
                throw new StorageException("无法读取文件: " + path);
            }
            
        } catch (MalformedURLException e) {
            throw new StorageException("无法读取文件: " + path, e);
        }
    }
    
    @Override
    public String getFileUrl(String path) {
        return baseUrl + "/" + path;
    }
    
    @Override
    public boolean deleteFile(String path) {
        try {
            Path filePath = getTargetPath(path);
            return Files.deleteIfExists(filePath);
        } catch (IOException e) {
            log.error("删除文件失败: {}", path, e);
            return false;
        }
    }
    
    @Override
    public boolean exists(String path) {
        Path filePath = getTargetPath(path);
        return Files.exists(filePath);
    }
    
    @Override
    public long getFileSize(String path) {
        try {
            Path filePath = getTargetPath(path);
            return Files.size(filePath);
        } catch (IOException e) {
            return 0;
        }
    }
    
    @Override
    public String copyFile(String sourcePath, String targetPath) throws StorageException {
        try {
            Path source = getTargetPath(sourcePath);
            Path target = getTargetPath(targetPath);
            
            Files.createDirectories(target.getParent());
            Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING);
            
            return targetPath;
            
        } catch (IOException e) {
            throw new StorageException("复制文件失败: " + sourcePath + " -> " + targetPath, e);
        }
    }
    
    @Override
    public String moveFile(String sourcePath, String targetPath) throws StorageException {
        try {
            Path source = getTargetPath(sourcePath);
            Path target = getTargetPath(targetPath);
            
            Files.createDirectories(target.getParent());
            Files.move(source, target, StandardCopyOption.REPLACE_EXISTING);
            
            return targetPath;
            
        } catch (IOException e) {
            throw new StorageException("移动文件失败: " + sourcePath + " -> " + targetPath, e);
        }
    }
    
    private Path getTargetPath(String path) {
        return Paths.get(basePath).resolve(path).normalize();
    }
}
```

#### 1.3 云存储实现（阿里云OSS）
```java
@Service
@Profile("aliyun")
public class AliyunOSSStorageService implements FileStorageService {
    
    @Value("${aliyun.oss.endpoint}")
    private String endpoint;
    
    @Value("${aliyun.oss.access-key-id}")
    private String accessKeyId;
    
    @Value("${aliyun.oss.access-key-secret}")
    private String accessKeySecret;
    
    @Value("${aliyun.oss.bucket-name}")
    private String bucketName;
    
    @Value("${aliyun.oss.base-url}")
    private String baseUrl;
    
    private OSS ossClient;
    
    @PostConstruct
    public void init() {
        ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);
        
        // 检查存储桶是否存在
        if (!ossClient.doesBucketExist(bucketName)) {
            throw new StorageException("OSS存储桶不存在: " + bucketName);
        }
    }
    
    @PreDestroy
    public void destroy() {
        if (ossClient != null) {
            ossClient.shutdown();
        }
    }
    
    @Override
    public String saveFile(MultipartFile file, String path) throws StorageException {
        try {
            ObjectMetadata metadata = new ObjectMetadata();
            metadata.setContentLength(file.getSize());
            metadata.setContentType(file.getContentType());
            metadata.setCacheControl("max-age=2592000"); // 30天缓存
            
            PutObjectRequest request = new PutObjectRequest(
                bucketName, 
                path, 
                file.getInputStream(), 
                metadata
            );
            
            ossClient.putObject(request);
            
            return path;
            
        } catch (Exception e) {
            throw new StorageException("保存文件到OSS失败: " + path, e);
        }
    }
    
    @Override
    public String saveFile(byte[] data, String path) throws StorageException {
        try {
            ObjectMetadata metadata = new ObjectMetadata();
            metadata.setContentLength(data.length);
            
            ByteArrayInputStream inputStream = new ByteArrayInputStream(data);
            PutObjectRequest request = new PutObjectRequest(bucketName, path, inputStream, metadata);
            
            ossClient.putObject(request);
            
            return path;
            
        } catch (Exception e) {
            throw new StorageException("保存文件到OSS失败: " + path, e);
        }
    }
    
    @Override
    public Resource getFileResource(String path) throws StorageException {
        try {
            if (!exists(path)) {
                throw new StorageException("文件不存在: " + path);
            }
            
            OSSObject ossObject = ossClient.getObject(bucketName, path);
            return new InputStreamResource(ossObject.getObjectContent());
            
        } catch (Exception e) {
            throw new StorageException("获取OSS文件失败: " + path, e);
        }
    }
    
    @Override
    public String getFileUrl(String path) {
        // 生成1小时有效的签名URL
        Date expiration = new Date(System.currentTimeMillis() + 3600 * 1000);
        URL signedUrl = ossClient.generatePresignedUrl(bucketName, path, expiration);
        return signedUrl.toString();
    }
    
    @Override
    public boolean deleteFile(String path) {
        try {
            ossClient.deleteObject(bucketName, path);
            return true;
        } catch (Exception e) {
            log.error("删除OSS文件失败: {}", path, e);
            return false;
        }
    }
    
    @Override
    public boolean exists(String path) {
        try {
            return ossClient.doesObjectExist(bucketName, path);
        } catch (Exception e) {
            return false;
        }
    }
    
    @Override
    public long getFileSize(String path) {
        try {
            ObjectMetadata metadata = ossClient.getObjectMetadata(bucketName, path);
            return metadata.getContentLength();
        } catch (Exception e) {
            return 0;
        }
    }
    
    @Override
    public String copyFile(String sourcePath, String targetPath) throws StorageException {
        try {
            CopyObjectRequest request = new CopyObjectRequest(
                bucketName, sourcePath, bucketName, targetPath);
            ossClient.copyObject(request);
            return targetPath;
        } catch (Exception e) {
            throw new StorageException("复制OSS文件失败: " + sourcePath + " -> " + targetPath, e);
        }
    }
    
    @Override
    public String moveFile(String sourcePath, String targetPath) throws StorageException {
        try {
            // OSS不支持移动，使用复制+删除
            copyFile(sourcePath, targetPath);
            deleteFile(sourcePath);
            return targetPath;
        } catch (Exception e) {
            throw new StorageException("移动OSS文件失败: " + sourcePath + " -> " + targetPath, e);
        }
    }
}
```

## 文件安全控制

### 1. 文件安全服务

#### 1.1 安全检查服务
```java
@Service
public class FileSecurityService {
    
    @Value("${file.security.virus-scan.enabled:true}")
    private boolean virusScanEnabled;
    
    @Value("${file.security.content-check.enabled:true}")
    private boolean contentCheckEnabled;
    
    @Autowired
    private VirusScanService virusScanService;
    
    @Autowired
    private ContentCheckService contentCheckService;
    
    public void scanFile(MultipartFile file) throws SecurityException {
        // 1. 文件名安全检查
        checkFileName(file.getOriginalFilename());
        
        // 2. 文件类型检查
        checkFileType(file);
        
        // 3. 文件内容检查
        if (contentCheckEnabled) {
            checkFileContent(file);
        }
        
        // 4. 病毒扫描
        if (virusScanEnabled) {
            scanVirus(file);
        }
    }
    
    private void checkFileName(String fileName) throws SecurityException {
        if (fileName == null || fileName.trim().isEmpty()) {
            throw new SecurityException("文件名不能为空");
        }
        
        // 检查危险字符
        String[] dangerousChars = {"../", "..\\", "<", ">", "|", ":", "*", "?", "\"", "script"};
        String lowerFileName = fileName.toLowerCase();
        
        for (String dangerousChar : dangerousChars) {
            if (lowerFileName.contains(dangerousChar)) {
                throw new SecurityException("文件名包含非法字符: " + dangerousChar);
            }
        }
        
        // 检查文件名长度
        if (fileName.length() > 255) {
            throw new SecurityException("文件名长度不能超过255个字符");
        }
    }
    
    private void checkFileType(MultipartFile file) throws SecurityException {
        String contentType = file.getContentType();
        String fileName = file.getOriginalFilename();
        
        if (contentType == null) {
            throw new SecurityException("无法确定文件类型");
        }
        
        // 检查文件扩展名和MIME类型是否匹配
        String extension = getFileExtension(fileName);
        if (!isValidFileType(extension, contentType)) {
            throw new SecurityException("文件类型不匹配: " + extension + " vs " + contentType);
        }
        
        // 检查是否为可执行文件
        if (isExecutableFile(extension)) {
            throw new SecurityException("不允许上传可执行文件: " + extension);
        }
    }
    
    private void checkFileContent(MultipartFile file) throws SecurityException {
        try {
            byte[] header = new byte[Math.min(1024, (int) file.getSize())];
            file.getInputStream().read(header);
            
            // 检查文件头
            if (containsExecutableHeader(header)) {
                throw new SecurityException("文件包含可执行代码");
            }
            
            // 检查脚本内容
            if (containsScriptContent(header)) {
                throw new SecurityException("文件包含脚本代码");
            }
            
        } catch (IOException e) {
            throw new SecurityException("文件内容检查失败", e);
        }
    }
    
    private void scanVirus(MultipartFile file) throws SecurityException {
        try {
            VirusScanResult result = virusScanService.scanFile(file);
            
            if (result.isInfected()) {
                throw new SecurityException("文件包含病毒: " + result.getVirusName());
            }
            
        } catch (VirusScanException e) {
            log.error("病毒扫描失败", e);
            // 扫描失败时根据配置决定是否允许上传
            if (isStrictMode()) {
                throw new SecurityException("病毒扫描失败，拒绝上传");
            }
        }
    }
    
    @Async
    public void asyncVirusScan(FileInfo fileInfo) {
        try {
            String filePath = getFullPath(fileInfo.getFilePath());
            VirusScanResult result = virusScanService.scanFile(new File(filePath));
            
            // 更新扫描结果
            fileInfo.setVirusScanStatus(result.isInfected() ? 2 : 1); // 1-正常，2-感染
            fileInfo.setVirusScanResult(result.getDetails());
            
            // 如果发现病毒，隔离文件
            if (result.isInfected()) {
                quarantineFile(fileInfo);
            }
            
        } catch (Exception e) {
            log.error("异步病毒扫描失败: {}", fileInfo.getId(), e);
            fileInfo.setVirusScanStatus(3); // 3-扫描失败
            fileInfo.setVirusScanResult(e.getMessage());
        }
        
        fileMapper.updateById(fileInfo);
    }
    
    private void quarantineFile(FileInfo fileInfo) {
        try {
            String originalPath = fileInfo.getFilePath();
            String quarantinePath = "quarantine/" + fileInfo.getId() + "_" + 
                                   System.currentTimeMillis() + "_" + fileInfo.getFileName();
            
            // 移动文件到隔离区
            storageService.moveFile(originalPath, quarantinePath);
            
            // 更新文件状态
            fileInfo.setStatus(0); // 标记为删除
            fileInfo.setFilePath(quarantinePath);
            
            // 发送安全告警
            securityAlertService.sendVirusAlert(fileInfo);
            
        } catch (Exception e) {
            log.error("隔离感染文件失败: {}", fileInfo.getId(), e);
        }
    }
    
    private boolean isValidFileType(String extension, String contentType) {
        Map<String, String> validTypes = Map.of(
            ".jpg", "image/jpeg",
            ".jpeg", "image/jpeg",
            ".png", "image/png",
            ".gif", "image/gif",
            ".pdf", "application/pdf",
            ".doc", "application/msword",
            ".docx", "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
            ".xls", "application/vnd.ms-excel",
            ".xlsx", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
        );
        
        return validTypes.get(extension.toLowerCase()) != null &&
               validTypes.get(extension.toLowerCase()).equals(contentType);
    }
    
    private boolean isExecutableFile(String extension) {
        String[] executableExtensions = {
            ".exe", ".bat", ".cmd", ".com", ".scr", ".pif", 
            ".msi", ".vbs", ".js", ".jar", ".app", ".deb", ".rpm"
        };
        
        return Arrays.stream(executableExtensions)
                    .anyMatch(ext -> ext.equalsIgnoreCase(extension));
    }
    
    private boolean containsExecutableHeader(byte[] header) {
        // 检查PE文件头 (Windows可执行文件)
        if (header.length >= 2 && header[0] == 'M' && header[1] == 'Z') {
            return true;
        }
        
        // 检查ELF文件头 (Linux可执行文件)
        if (header.length >= 4 && header[0] == 0x7F && header[1] == 'E' && 
            header[2] == 'L' && header[3] == 'F') {
            return true;
        }
        
        return false;
    }
    
    private boolean containsScriptContent(byte[] header) {
        String content = new String(header, StandardCharsets.UTF_8).toLowerCase();
        
        String[] scriptPatterns = {
            "<script", "javascript:", "vbscript:", "onload=", "onerror=",
            "<?php", "<%", "<jsp:", "#!/bin/sh", "#!/bin/bash"
        };
        
        return Arrays.stream(scriptPatterns)
                    .anyMatch(content::contains);
    }
}
```

## 总结

文件管理系统设计涵盖了以下核心要点：

### 设计特色
- **分层架构设计**: 前端组件、API网关、文件服务、存储系统四层架构
- **多存储策略**: 本地存储、云端存储、CDN分发的灵活组合
- **图片智能处理**: 自动压缩、格式转换、缩略图生成、水印添加
- **完整安全控制**: 文件类型验证、病毒扫描、内容检查、访问权限控制

### 功能亮点
- **拖拽上传**: 支持拖拽和点击两种上传方式，实时进度显示
- **图片编辑**: 集成裁剪、压缩、格式转换等图片处理功能
- **版本控制**: 支持文件版本管理和历史版本追溯
- **文件去重**: 基于MD5哈希的文件去重机制
- **访问控制**: 基于角色和业务关联的精细化权限控制

### 安全保障
- **文件扫描**: 上传前后的多重安全检查和病毒扫描
- **内容验证**: 文件头检查、脚本内容检测、可执行文件拦截
- **传输安全**: HTTPS传输、文件加密存储、签名URL访问
- **审计日志**: 完整的文件操作审计和异常行为监控

### 技术优势
- **存储抽象**: 统一的存储服务接口，支持多种存储后端
- **异步处理**: 图片处理、病毒扫描等耗时操作异步执行
- **缓存优化**: 缩略图缓存、热点文件缓存提升访问性能
- **弹性扩展**: 支持云存储、CDN等扩展方案

该文件管理系统为CRM提供了完整的文件服务能力，确保了文件的安全性、可靠性和高性能访问。
